<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tiny Hill&#39;s Blog</title>
  
  <subtitle>区块链小山的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-20T01:52:14.388Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tiny Hill</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么 Defis Network 的 USDD 会失败？</title>
    <link href="http://yoursite.com/2020/07/20/2020-7-20-DEFIS-NETWORK/"/>
    <id>http://yoursite.com/2020/07/20/2020-7-20-DEFIS-NETWORK/</id>
    <published>2020-07-20T01:00:00.000Z</published>
    <updated>2020-07-20T01:52:14.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没有爆仓的借贷是一种妄念</p></blockquote><h1 id="为什么需要抵押稳定币"><a href="#为什么需要抵押稳定币" class="headerlink" title="为什么需要抵押稳定币"></a>为什么需要抵押稳定币</h1><p>目前的稳定币主要分为两类，一类是通过美金准备金进行刚性兑付的中心化稳定币。比如 USDT 和 USDC 等，这些稳定币或合规，或不合规，都或多活少收到政府监管。最近就又几起稳定币司法冻结的事件。初次之外，是否真的能够刚性兑付这个事情，因为账目不透明所以，一直是一个迷。</p><p>所以，基于抵押所产生的，原生区块链资产稳定币，成为一个需求。在这个赛道上，出现过BitCNY，Dai等稳定币项目。</p><h1 id="什么是好的抵押稳定币"><a href="#什么是好的抵押稳定币" class="headerlink" title="什么是好的抵押稳定币"></a>什么是好的抵押稳定币</h1><p>标准非常简单，是否能够长期稳定，不出现脱离锚定的情况。</p><p>这这个标准下，还有一些指标来判断稳定币</p><ul><li>资金利用率，就是抵押物的抵押倍数。抵押倍数低，资金利用率就高</li><li>爆仓效率，在抵押物价值快速下跌的过程中，能够及时爆仓保证资金风险</li></ul><h1 id="什么是-USDD"><a href="#什么是-USDD" class="headerlink" title="什么是 USDD"></a>什么是 USDD</h1><p>USDD 是 Defis Networs（DFS）项目，通过超额抵押产生的抵押稳定币。</p><p>他和其他抵押稳定币有什么区别？他需要3倍的超额抵押，就是如果 EOS价值3美金，那他只能生成一个USDD。</p><p>同时，他没有爆仓机制。</p><h1 id="为什么-USDD会失败"><a href="#为什么-USDD会失败" class="headerlink" title="为什么 USDD会失败"></a>为什么 USDD会失败</h1><h2 id="摆事实"><a href="#摆事实" class="headerlink" title="摆事实"></a>摆事实</h2><p>USDD目前长时间对应EOS的价格在 2.2 EOS/USDD 以下，夸张的时候到过1.5 EOS/USDD。</p><p>实际上 EOS的价格为 2.6 EOS/USDT。溢价一度超过 50%</p><h2 id="讲道理"><a href="#讲道理" class="headerlink" title="讲道理"></a>讲道理</h2><h3 id="高额抵押"><a href="#高额抵押" class="headerlink" title="高额抵押"></a>高额抵押</h3><p>高额抵押，意味着，如果稳定币溢价，套利的难度非常大。套利者抵押生成USDD后再用USDD换EOS，这样套利者的资金就被占用，套利的金额有限。</p><p>与3倍高额的抵押相对应的，EOS上另外一个稳定币 VIGOR，只需要1.1倍的抵押就可以生成，那样的话，如果溢价超过10%，套利者就可以无限套利，所以溢价不可能超过10%。</p><h3 id="无爆仓"><a href="#无爆仓" class="headerlink" title="无爆仓"></a>无爆仓</h3><p>设计者希望能够不爆仓生成稳定币，所以使用了3倍的高额抵押。那么是否就真的安全了？</p><p>今年3.12的极端行情，下跌3倍是有可能发生的。那时候，USDD将会资不抵债。</p><p>这个事情DAI的2倍超额抵押，就发生了。DAI是有爆仓的，但是因为ETH网络拥堵，所以爆仓交易被堵住了，最终导致了项目方拍卖MKR来进行补偿。</p><p>而EOS的速度不存在问题，为何要如此放弃自己的优势呢？</p><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>用户挖矿是比不过科学家的，用户的机会可能就是赌它的上涨，具体会不会涨，这个不在我的能力范围。</p><h1 id="也说一些好事"><a href="#也说一些好事" class="headerlink" title="也说一些好事"></a>也说一些好事</h1><p>目前 EOS/USDD 池子的深度已经有2W+ 的EOS了，这是目前来看，EOS生态里面最大的swap 池子了，这个项目如果能够激活EOS Defi生态，当然是最好不过的事情了。</p><h1 id="其他-EOS-Defi"><a href="#其他-EOS-Defi" class="headerlink" title="其他 EOS Defi"></a>其他 EOS Defi</h1><ul><li>EOSDT 抵押稳定币，存币生息</li><li>Pizza/USDE 抵押稳定币，借贷，交易</li><li>Bancor/USDB 交易，稳定币</li><li>Vigor 抵押稳定币，DAC</li><li>Newdex / Newdex Swap 交易</li><li>sx swap 交易</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;没有爆仓的借贷是一种妄念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;为什么需要抵押稳定币&quot;&gt;&lt;a href=&quot;#为什么需要抵押稳定币&quot; class=&quot;headerlink&quot; title=&quot;为什么需要抵押稳定币&quot;&gt;&lt;/a&gt;为什么需要抵押稳定
      
    
    </summary>
    
    
      <category term="区块链轶事" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%BD%B6%E4%BA%8B/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>Fabric学习开篇</title>
    <link href="http://yoursite.com/2020/03/17/2020-6-1-CHFD/"/>
    <id>http://yoursite.com/2020/03/17/2020-6-1-CHFD/</id>
    <published>2020-03-17T08:24:00.000Z</published>
    <updated>2020-06-01T05:54:10.118Z</updated>
    
    <content type="html"><![CDATA[<p>根据 《Certified Hyperledger Fabric Developer》考试要求学习 Fabric</p><a id="more"></a><p>因为工作原因，又需要学习 Hyperledger Fabric 相关的内容，目前Fabric和两年前比起来已经有了一些变化。虽然我还是非常不认可它的设计，但是挡不住公司用它。</p><p>因为要考 CHFD，所以还是需要系统学习一下。打算把学习的内容固化下来。</p><p>今天就先把考试的大纲列一下，后续不断更新。</p><h1 id="CHFD-Domains-amp-Competencies-v1-0"><a href="#CHFD-Domains-amp-Competencies-v1-0" class="headerlink" title="CHFD Domains &amp; Competencies v1.0"></a>CHFD Domains &amp; Competencies v1.0</h1><h2 id="Identity-Management-–-7"><a href="#Identity-Management-–-7" class="headerlink" title="Identity Management – 7%"></a>Identity Management – 7%</h2><ul><li>Instantiate a wallet</li><li>Import identities to a wallet</li><li>Select and manage identity from a wallet</li></ul><h2 id="Network-Configuration-–-8"><a href="#Network-Configuration-–-8" class="headerlink" title="Network Configuration – 8%"></a>Network Configuration – 8%</h2><ul><li>Create and use connection profiles</li><li>Instantiate and connect to a gateway</li><li>Access networks and contracts</li></ul><h2 id="Smart-Contract-Development-–-40"><a href="#Smart-Contract-Development-–-40" class="headerlink" title="Smart Contract Development – 40%"></a>Smart Contract Development – 40%</h2><ul><li>Define smart contract class/construct</li><li>Define transaction functions</li><li>Validate and sanitize inputs and arguments</li><li>Implement deterministic logic/code</li><li>Simple state interaction (Get, Put, Delete)</li><li>Execute simple queries</li><li>Create complex queries</li><li>Define assets using key value pairs</li><li>Identify potentially private data</li><li>Incorporate private data collection</li><li>Implement attribute based access control</li><li>Initialization of the ledger state</li><li>Install and instantiate a smart contract</li></ul><h2 id="Smart-Contract-Invocation-–-25"><a href="#Smart-Contract-Invocation-–-25" class="headerlink" title="Smart Contract Invocation – 25%"></a>Smart Contract Invocation – 25%</h2><ul><li>Invoke smart contracts via CLI</li><li>Submit one or more transactions</li><li>Evaluate transaction functions e.g. for queries</li><li>Query transaction history</li><li>Call a transaction using transaction class (stateful)</li><li>Create and issue an application contract</li><li>Register and handle channel-based events</li></ul><h2 id="Maintenance-and-Testing-–-20"><a href="#Maintenance-and-Testing-–-20" class="headerlink" title="Maintenance and Testing – 20%"></a>Maintenance and Testing – 20%</h2><ul><li>Handle error and success responses</li><li>Identify and review logs</li><li>Unit test contracts</li><li>Diagnose and endorse policy conflicts</li><li>Identify and correct non-determinism in functions</li><li>Troubleshoot transaction flow</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 《Certified Hyperledger Fabric Developer》考试要求学习 Fabric&lt;/p&gt;
    
    </summary>
    
    
      <category term="Fabric" scheme="http://yoursite.com/categories/Fabric/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://yoursite.com/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Codex 和 Uniswap 的区别</title>
    <link href="http://yoursite.com/2020/03/17/2020-3-17-CODEX-UNISWAP/"/>
    <id>http://yoursite.com/2020/03/17/2020-3-17-CODEX-UNISWAP/</id>
    <published>2020-03-17T08:24:00.000Z</published>
    <updated>2020-03-17T09:15:31.818Z</updated>
    
    <content type="html"><![CDATA[<p>Codex 是运行在 EOS 上的基于底池的自动做市商交易所，它和该模型的鼻祖 Uniswap 之间有什么异同？</p><a id="more"></a><p>在之前介绍 FIBOS DEX 的时候已经介绍过 Uniswap 的机制。 这种机制通过底池提供流动性，用户可以立即与底池交易，无需挂单。</p><p>它的核心算法其实很简单，当前价格为底池两种资产的比值，交易前后，底池中两种资产的乘积相等。</p><p>这种机制对于深度较差的交易对，对于小额交易的用户，往往能够提供相对挂单更好的体验，因为用户可以立即成交。而挂单的交易所往往买一和卖一差价很大，用户无法用比较好的价格成交。但是对于大额交易的用户，则不如挂单交易所，因为大额交易会对底池的资金量造成比较大的影响从而导致价格的滑点，结果就是用户无法按照预期的价格成交。</p><p>所以，决定 Uniswap 类交易所使用体验的一个很重要的因素就是底池的深度。</p><p>那么 Codex 又有什么特别的地方？</p><h2 id="平台币"><a href="#平台币" class="headerlink" title="平台币"></a>平台币</h2><p>Codex 和 Uniswap 最显著也是最重要的区别在与平台币。</p><p>Uniswap 没有平台币，是一个很纯粹的项目。所有底池资金由用户提供，来赚取利润，同时也需要承担交易对价格波动的风险。其交易手续费为双向 0.3%。也由一些项目方，比如 Synthetix，会激励用户存入底池提供流动性。</p><p>而 Codex 有平台币，EIDOS，整个 Codex 都是围绕着这个平台币来构建的。在 Codex 中，所有 Token 只和 EIDOS 形成底池和直接交易对。用 EIDOS 购买 Token 收取 0.1%的手续费，而用 Token 买 EIDOS 则不收费。通过 EIDOS 作为中转，可以连接其他两种 Token，形成级联的交易对，级联的交易对双向 0.1%的手续费。同样是级联交易，在 Uniswap 中，因为中转一次，就需要收取 0.6%的手续费。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>主打平台币中转的模式，对于一个新加入的币种快速获得流动性是有非常大的帮助的。</p><p>目前 EOS/EIDOS 和 USDT/EIDOS 已经存在一定的流动性。一个新的币种，只要补充其对 EIDOS 的底池，提供一定的流动性，他们它将立即获得与 EOS 和 USDT 的交易深度。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>而这种平台币模式，也可能是一把双刃剑。目前 EIDOS 还是一个波动非常大的资产，即使相对 EOS 和 USDT 都是如此。那么对于某个代币的项目方，如果想要在 Codex 中提供流动性，那么就不得不承担 EIDOS 波动的风险。</p><p>这里补充说明一下，存入流动性所存在的风险。如果你存入底池的，你会得到底池中两种资产的赎回权，但是具体你的权益对应两种资产的比例则是根据价格不断变化的。举例，一开始你的权益对应 1 EOS 和 100 EIDOS ， 如果 EIDOS 价格一直涨，那么你的权益可能变为 2 EOS 和 50 EIDOS，相反，也可能变成 0.5 EOS 和 200 EIDOS。</p><p>如果你只在意交易对中的一种资产，而且价格剧烈变化的话，你将承担不小的风险。</p><p>所以，我对于想要存入 Codex 底池的用户有一个建议：<strong>存入双边币种你都希望持有的交易对</strong>，比如，你对 EIDOS 和 YAS 都非常看好，那么无论价格怎么变化，对你来说只是赎回的代币比例的变化，同时，还可以获取交易的手续费，是一个很保险的理财。</p><p>除此之外，Codex 的交易手续费从最开始的 1%到目前只有 0.1%，一定程度降低了用户存入底池的积极性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Codex 之后可能会推出跨链铆钉资产，这个目前还没上线，也无法详细去研究。</p><p>目前来看， Codex 和 Uniswap 最主要的区别就是平台币 EIDOS 的存在，Codex 的成败与 EIDOS 的接受度，存在强绑定的关系。</p><p>这样的绑定关系是好是坏，只能拭目以待。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Codex 目前是一个底层的协议，项目方没有推出用户界面。</p><p>我做了一个用户界面 <a href="https://codex.easypayeos.com" target="_blank" rel="noopener">Codex+</a> , 同时集成了 Easy Pay 的资源代付功能，欢迎各位使用。也可以向 codexplusdev 账号捐赠来支持我们的工作，EOS 和 YAS 主网都是这个账号。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Codex 是运行在 EOS 上的基于底池的自动做市商交易所，它和该模型的鼻祖 Uniswap 之间有什么异同？&lt;/p&gt;
    
    </summary>
    
    
      <category term="DeFi" scheme="http://yoursite.com/categories/DeFi/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Uniswap" scheme="http://yoursite.com/tags/Uniswap/"/>
    
      <category term="Codex" scheme="http://yoursite.com/tags/Codex/"/>
    
  </entry>
  
  <entry>
    <title>RSK 如何做到低费用高安全</title>
    <link href="http://yoursite.com/2020/03/03/2020-3-5-RSK-FEE/"/>
    <id>http://yoursite.com/2020/03/03/2020-3-5-RSK-FEE/</id>
    <published>2020-03-03T08:24:00.000Z</published>
    <updated>2020-03-17T09:17:12.496Z</updated>
    
    <content type="html"><![CDATA[<p>RBTC 是 RSK 公链的基础代币，1:1 锚定 BTC，那么 RSK 是否存在 RBTC 的区块奖励？这些奖励从哪里来？</p><a id="more"></a><p><a href="https://blog.rsk.co/zh-hans/noticia/%e6%af%94%e7%89%b9%e5%b8%81%e5%90%88%e5%b9%b6%e6%8c%96%e7%9f%bf%e5%8c%ba%e5%9d%97%e9%93%be%e7%9a%84%e7%9b%88%e5%88%a9%e8%83%bd%e5%8a%9b%e7%a0%94%e7%a9%b6/" target="_blank" rel="noopener">RSK 文档链接</a></p><p>没有详细了解 RSK 之前，有一个问题一直困扰我。既然 RSK 使用 RBTC 作为基础代币，那么作为区块奖励的 RBTC 从何而来？如果是自身增发，那么 RBTC 和 BTC 的 1:1 必然不可持续。如果是使用基金会募资来补贴，也必然不是长久之际。</p><p>那答案是什么呢？RSK 的区块奖励只包括交易手续费，而没有一般区块链的 coinbase（币基）奖励。这意味着矿工的所有收入都来源于交易手续费，RBTC 不存在增发。</p><p>依赖双挖的特性，BTC 的矿工可以在挖 BTC 的同时一起挖 RSK 而不付出多余的代价。<strong>这就是矿工愿意接入 RSK 的原因</strong>。</p><p>RSK 大约每 30 秒出块秒，每个区块的手续费平均为 0.00006844 RBTC，每月的区块奖励大概在 6 个 RBTC。虽然手续费的收入不算多，但是聊胜于无。目前已经有大约 40%的 BTC 算力同时参与 RSK 挖矿。</p><p>正因为有双挖的机制，RSK 能够提供很高的安全性，同时在交易手续费方面又可以保持较低的水平。RSK 目前的手续费大幅低于 BTC，而且低于以太坊的费率。</p><p>RSK 完全兼容以太的智能合约，在以太升级 POS 所导致的各种隐忧的情况下，一些希望长久稳定，并且希望由大算力护航的项目，不妨考虑一下 RSK。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RBTC 是 RSK 公链的基础代币，1:1 锚定 BTC，那么 RSK 是否存在 RBTC 的区块奖励？这些奖励从哪里来？&lt;/p&gt;
    
    </summary>
    
    
      <category term="RSK" scheme="http://yoursite.com/categories/RSK/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="RBTC" scheme="http://yoursite.com/tags/RBTC/"/>
    
  </entry>
  
  <entry>
    <title>RBTC 的跨链安全性</title>
    <link href="http://yoursite.com/2020/03/03/2020-3-3-RSK-SECURITY-MODEL/"/>
    <id>http://yoursite.com/2020/03/03/2020-3-3-RSK-SECURITY-MODEL/</id>
    <published>2020-03-03T08:24:00.000Z</published>
    <updated>2020-03-03T12:48:36.875Z</updated>
    
    <content type="html"><![CDATA[<p>RBTC 是 RSK 公链的基础代币，1:1 锚定 BTC，那么 RBTC 是如何做到安全和去中心化的？</p><a id="more"></a><p><a href="https://developers.rsk.co/rsk/architecture/security/" target="_blank" rel="noopener">RSK 文档链接</a></p><p>由于 DeFi（去中心化金融）对于智能 BTC 的需求，目前已经有很多不同类型的 BTC 跨链项目在运行了，而 RSK 的 RBTC 也是这条赛道最早的竞争者之一。</p><p>我们都知道，BTC 的跨链，实际上就是在 Bitcoin 链上锁定，再在另外一条链上发行同样金额的币，反方向则是销毁和解锁。</p><h2 id="RBTC-的跨链安全性"><a href="#RBTC-的跨链安全性" class="headerlink" title="RBTC 的跨链安全性"></a>RBTC 的跨链安全性</h2><p>由于 Bitcoin 不是一个图灵完备的公链，理论上，无法做到完全的去信任跨链。RSK 在 Bitcoin 链上的锁定的 BTC 资产安全由一组可信第三方（简称 STTP）来保证。这些可信第三方组成了 RSK 联合会（Federation），没有一个单独的 STTP 能够操控锁定的 BTC，只有大多数 STTP 通过才能够释放 BTC 资产。当 STTP 监控到 RSK 链上发起的跨链转账 BTC，STTP 多签执行解锁的操作。除此之外，用户在 Bitcoin 链上发起的跨链转账所锁定的 BTC 并不会固定锁定在一个单独的地址中，RSK 锁定的 BTC 是一个大池子，统一管理。</p><p>RSK 联合会成员进行锁定和解锁 BTC 是无需人为干预的。加入 RSK 联合会需要首先对成员的节点程序进行审核，确保节点的基础设施能够提供正确的操作，此外 RSK 实验室也开发了针对 STTP 的硬件安全模块来保证私钥的安全。</p><p>截至 2019 年 1 月，RSK 联合会由 15 名知名且高度安全的公证人组成。这些领先的区块链公司通过自治协议来安全锁定 BTC。作为报酬，RSK 联合会成员将获得 RSK 产生的交易费用的 1％，以支付硬件和维护成本。联合会成员的更替由智能合约负责，因此对公众开放。更替生效之前有一个强制性的延迟一周。 如果用户不信任新的 RSK 联合会成员，用户可以将 BTC 转移回 Bitcoin 网络。</p><p>如果之后 Bitcoin 通过升级添加了特殊的操作码或可扩展性来支持使用 SPV 验证，RSK 将升级跨链的机制来支持完全去中心化的实现。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>搜索了很多资料，关于 RSK 联合会的信息很少，官网中并没有找到，唯一找到的<a href="https://news.bitcoin.com/rsk-federation-partners-industry-leaders/" target="_blank" rel="noopener">文章</a>中列出了成员包括：</p><ul><li>Bitgo</li><li>Bitpay</li><li>Bitstamp</li><li>Blockchain</li><li>Blockchain Intelligence Group</li><li>Bitfinex</li><li>BTCC</li><li>Jaxx</li><li>Huobi</li><li>OKCoin</li><li>Xapo</li></ul><p>确实都是一些业界最知名的公司。</p><p>除了 RBTC，其他一些跨链 BTC 的项目，也都是类似的多机构或者单机构的公证人机制。在目前 Bitcoin 非图灵完备的情况下，还有没有可能出现其他方式的跨链？这是一个值得期待的问题。</p><p>关于其他 BTC 跨链项目，可以看看(<a href="https://www.chainnews.com/articles/969112149833.htm" target="_blank" rel="noopener">https://www.chainnews.com/articles/969112149833.htm</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RBTC 是 RSK 公链的基础代币，1:1 锚定 BTC，那么 RBTC 是如何做到安全和去中心化的？&lt;/p&gt;
    
    </summary>
    
    
      <category term="RSK" scheme="http://yoursite.com/categories/RSK/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="RBTC" scheme="http://yoursite.com/tags/RBTC/"/>
    
  </entry>
  
  <entry>
    <title>[翻译] Voice：通往测试版之路</title>
    <link href="http://yoursite.com/2020/02/06/2020-2-6-VOICE-ROAD-TO-BETA/"/>
    <id>http://yoursite.com/2020/02/06/2020-2-6-VOICE-ROAD-TO-BETA/</id>
    <published>2020-02-06T08:24:00.000Z</published>
    <updated>2020-03-03T12:48:30.353Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://voice.com/blog/road-to-beta/" target="_blank" rel="noopener">原文链接</a></p><p>六个月前，我们的首席执行官 Brendan Blumer 和首席技术 Dan Larimer 在拥挤的华盛顿特区礼堂举行了一场激烈的演讲。主题是社交媒体的现状。</p><a id="more"></a><p>好吧，它并不是真正的“激烈”。它更多地是一场涉及次贷危机、区块链演变和社会心理的多元运动演说。</p><p>但所有这些都归结为：</p><p>  <strong>社交媒体”坏”了。社交媒体被设计去利用我们的数据和注意力，为大型集团公司、大型科技公司、银行和华尔街利益集团创造了数万亿美元的利润，与此同时，我们努力保护自己免受注意力被拍卖给匿名方以及个人信息在公开市场上交易的后果。我们与曾经信任的平台之间的利益失衡，使我们越来越容易遭受数据剖析、身份盗窃、网络欺凌和有说服力的错误信息的影响。越来越多的人想要操纵我们的思想并控制自己的行为，在制造出来的信息海洋中去了解真相从未如此困难。</strong></p><p>这就是为什么我们如此专注于Voice的原因：一个基于区块链的社交网络，重新组合用户喜好的公式————消除不透明的单方面数据拍卖，去除隐藏的算法，并通过Voice代币的形式将价值循环回用户手中。通过做自己并表达自己的声音即可获得Voice代币；它们具有影响注意力的效用，可用于在整个生态系统中以不同的方式提升内容。换句话说，我们相信Voice应该是社交性的————那些对平台有利的也对您有利。</p><p>自从我们宣布这一消息以来，成千上万的人已经申请测试版，意见领袖已经宣布支持，媒体也在要求我们提供信息和时间表————正如您也是如此。我们很高兴看到这样的情况，希望你们一直保持下去。</p><p>接下去是什么？</p><p>与大多数新兴技术一样，让人们能够使用Voice不仅需要认真的开发。法律环境仍在不断发展，而区块链与代币化以及社交媒体的结合相对来说尚属未知领域。因此，我们正在与立法部门和监管机构进行持续的公开对话，以确保Voice已为用户准备就绪。</p><p>可以说，这是一条漫长而未铺砌的市场之路。但是我们进展顺利————我们的目标是在<strong>2020年2月14日</strong>发布测试版。</p><p>从现在开始，我们希望与大家分享我们的旅程。行业变革不会一蹴而就，也不会凭空而来。在此过程的每个阶段，没有您的参与，仔细检查和反馈，Voice将无法达成它应有的样子。因此，可以将此篇博客视为公开邀请。我们的最新发现、最大的挑战以及Dan和开发人员的故事，还有法规更新和幕后窥视，我们正准备将其发布在这里，希望产生一些变化，因此您可以与我们一起迈向测试版。再见。</p><h2 id="加入Voice对话"><a href="#加入Voice对话" class="headerlink" title="加入Voice对话"></a>加入Voice对话</h2><p>在<a href="https://twitter.com/voicesocial_" target="_blank" rel="noopener">Twitter</a>，<a href="https://www.facebook.com/getvoicesocial" target="_blank" rel="noopener">Facebook</a>和<a href="https://www.instagram.com/Voice_Social_/" target="_blank" rel="noopener">Instagram</a>上关注我们以获取最新更新，或访问我们的<a href="https://voice.com/blog/road-to-beta/" target="_blank" rel="noopener">常见问题解答</a>，随着我们不断发展Voice，我们将添加新的更新和信息。在这里，您可以看到别人在问什么，并添加自己的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://voice.com/blog/road-to-beta/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;六个月前，我们的首席执行官 Brendan Blumer 和首席技术 Dan Larimer 在拥挤的华盛顿特区礼堂举行了一场激烈的演讲。主题是社交媒体的现状。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
      <category term="Voice" scheme="http://yoursite.com/tags/Voice/"/>
    
  </entry>
  
  <entry>
    <title>VOICE FAQ（常见问题）翻译</title>
    <link href="http://yoursite.com/2020/02/05/2020-2-5-VOICE-FAQ/"/>
    <id>http://yoursite.com/2020/02/05/2020-2-5-VOICE-FAQ/</id>
    <published>2020-02-05T08:24:00.000Z</published>
    <updated>2020-02-05T11:49:32.387Z</updated>
    
    <content type="html"><![CDATA[<p>Voice 是由 Block.one 公司推出的社交网站，基于EOSIO区块链。这里翻译一下官方的问答，基于谷歌翻译并做微调。</p><p><a href="https://voice.com/faq/" target="_blank" rel="noopener">原文链接</a></p><p><strong>Voice是什么？</strong></p><p>Voice是用于创建、分发和发现内容的公开透明、基于奖励的社交网络。它旨在通过身份认证和公开透明的数据库基础结构来培养新的可信任的体验。<br>Voice由用户构成并为了用户而创建的。大部分价值通过Voice代币返回到社区，Voice代币是一种实用代币，可以通过获取和使用来获得网络上其他用户的关注。</p><a id="more"></a><p><strong>是什么使Voice在技术上与众不同？</strong></p><p>利用Block.one开发的开源EOSIO协议，Voice充分利用了区块链技术的固有特性：安全性和可审计性。通过Voice，我们促进了可信任且透明的社交互动，以及对平台内容推广方式的可见性。</p><p><strong>什么是Voice代币，如何获得？</strong></p><p>Voice代币是消耗性的实用代币，用来引起其他用户的注意；您可以将它们花费在特定内容上，以增加在平台上的曝光度。由于每个人都有被倾听的权利，因此用户每天都会获得相同数量的Voice代币。您可以通过创建其他人消费和欣赏的内容来获得Voice代币。最初，您可以使用代币购买发布的内容下方的空间，但Voice代币被认为是平台上所有形式的促销和广告的中介。</p><p>随着测试版的发布，我们将在Voice博客上发布更多有关Voice代币，以及分发机制和消费模型的详细信息。</p><p><strong>与其他社交媒体相比，Voice上的促销和广告有何不同？</strong></p><p>Voice代币位于区块链账本中，该账本对存储的数据库实现了前所未有的透明性，包括整个平台上的促销和广告。通过使用户能够看到促销内容的背后的发起人和促销方式，使得促销活动更加吸引人并且更少的误导性。这种可审核的透明度还扩展到Voice代币的分发和使用，Voice代币由作者和用户获得，并由寻求推广的人花费。</p><p><strong>那些更被动，主要只是消费内容的社交媒体用户呢？ 他们为什么要使用Voice？</strong></p><p>真实用户。 真实内容。 实际价值。 Voice专为消费者和内容创作者而设计。 Voice上的每个用户将有权影响哪些内容获得的热度，为了确保这一点，所有经过验证的用户每天将获得相等数量的Voice代币。 我们相信每个人的意见都很重要，而Voice代币就是我们确保其真正做到的方式。</p><p><strong>如何使用Voice代币来推广内容？</strong></p><p>Voice上的每个帖子都有机会被“听到”。 这意味着用户可以将其Voice代币消费到帖子中并控制顶部评论。 此操作可奖励内容创建者，并为帖子带来更多可见度。 那时，用户的Voice代币已花费在帖子上。 如果其他人提供了更多Voice代币来控制指定文章上的最高评论点，则前竞标者将失去对该位置的控制权，但获得的Voice代币要比他们最初花费的Voice代币多。 然后，他们可以决定是否要为该位置重新出价以重新获得控制权。</p><p><strong>与其他未能处理假新闻，欺凌和操纵行为的社交平台相比，Voice的工作方式有何不同？内容将如何审核？</strong></p><p>当前社交媒体平台上发生的大规模攻击和操纵，很大程度上是由于无法将内容归因于终端用户，因此为假冒、商业化和操纵性内容和行为营造了猖獗的环境。Voice的用户是经过验证的真实身份，旨在通过将所有内容归因于特定人员的能力来极大地减少假帐户和非法内容的流行。</p><p>适用性仍然是一个问题，控制应用的规则通常不由平台运营商所控制，而由监管机构和适用法律掌握。作为一家公司，我们相信言论自由，并会在遵守所有法律法规的前提下优先考虑该价值。</p><p>我们希望将来能够实现分散的内容分发和审核，但是对于第一阶段，我们主要致力于提供那些可以用许多令人兴奋的方式进行扩展的核心功能。</p><p><strong>Voice的所有用户都将被要求验证身份吗？</strong></p><p>除了单纯内容消费之外，其他所有的场景都需要验证身份。 真实性是使社交媒体保持一致的基础，而身份验证将确保每个帐户都属于一个真实的人。 经过验证的身份有助于消除机器人程序、虚假新闻以及由做恶者隐藏在匿名和商业利益背后而造成的困扰现有社交平台的其他负面体验，并有助于与代币化经济体进行更深入的合规性互动。 我们并没有忘记实现这一目标所会遇到的障碍，但是我们知道它所带来的变革性经验是值得去克服这些障碍的，我们还会专注于使流程尽可能简化和容易。</p><p><strong>Voice测试版是什么样子？</strong></p><p>与所有雄心勃勃的新产品一样，Voice将需要迭代和反复试验，以确保满足以用户为中心，安全性强且人们喜欢它。 随着我们不断进行迭代，有关产品和此问答的许多事情也会改变。 测试版将向社区成员敞开大门，让他们首次体验Voice，测试其设计并开始建立您的网络。</p><p><strong>如何实现Voice博客测试版</strong></p><p>透明度是我们所做工作的核心，并且在我们持续构建Voice的过程中，这部分意味着向我们的社区敞开大门，让他们亲眼目睹Block.one为实现Voice所做的努力、成功和所采取的步骤。</p><p>在未来的几个月中，我们希望通过我们的博客和常见问题解答，就当今困扰社交媒体的问题，与社区进行对话，说明Voice在改变社交媒体范式中所扮演的角色以及我们启动测试版的方式。 我们的博客将重点介绍过程中有趣的方面，因为我们能够应对面临的挑战和所看到的机遇。 在新的Voice博客中可以找到最早的测试公告，以及我们即将推出而不断增长的问答。</p><p><strong>Voice何时可用？</strong></p><p>Voice团队正在努力争取在2020年2月14日发布Voice的公共测试版。您可以在Voice.com上请求测试版的访问权限，以了解最新动态。 虽然Voice测试的初始版本仅是英语，且功能有限，但我们希望使尽可能多的人可以使用它，以开始体验此方向并提供反馈。 如果您尚未请求测试版访问权限，我们鼓励您加入我们。</p><p><strong>Voice将在哪里运行？</strong></p><p>当Voice处于测试状态且处于高度迭代状态时，它将在特定的EOSIO区块链上运行。 随着时间的流逝，我们希望Voice能够利用EOS公链以及可能满足Voice的性能和治理要求的其他区块链。</p><p><strong>哪些国家可以使用测试版Voice？</strong></p><p>Voice旨在成为一个欢迎不同体验和文化的全球社区，这就是我们的目标。 在朝着这个目标努力的过程中，Voice 测试版最初将以英语发布，并在许多可行的发布国家/地区发布。 随着我们针对本地语言，标准和法规环境改进和优化，我们的目标是继续提高世界各地不同国家和语言的用户的可访问性。 我们将继续在Voice博客中及时更新社区信息，以及在发布过程中面临的任何挑战，因为我们打算尽快将邀请尽可能广泛地发出。</p><p><strong>有兴趣加入Block.one来开发Voice吗？</strong></p><p>我们始终欢迎对Voice有兴趣希望加入Block.one的人。 有关加入Block.one团队的更多信息，请访问我们的职业页面以查看我们目前正在招聘的职位。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Voice 是由 Block.one 公司推出的社交网站，基于EOSIO区块链。这里翻译一下官方的问答，基于谷歌翻译并做微调。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://voice.com/faq/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Voice是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Voice是用于创建、分发和发现内容的公开透明、基于奖励的社交网络。它旨在通过身份认证和公开透明的数据库基础结构来培养新的可信任的体验。&lt;br&gt;Voice由用户构成并为了用户而创建的。大部分价值通过Voice代币返回到社区，Voice代币是一种实用代币，可以通过获取和使用来获得网络上其他用户的关注。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>关于传染病的过激反应</title>
    <link href="http://yoursite.com/2020/01/23/2020-1-23/"/>
    <id>http://yoursite.com/2020/01/23/2020-1-23/</id>
    <published>2020-01-23T14:24:00.000Z</published>
    <updated>2020-01-23T14:56:34.158Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>传染病的季节，怕死的人该如何自处？</p></blockquote><p>经过了两天的纠结与折腾，终于决定了取消回家的计划。随着疫情的不断变化加剧，从坐火车到开车到取消，实在是让人心累。</p><p>不知道是有了宝宝之后怕死还是自己原来就这么怕死，但是对于这次的疫情，我表现出了异常的敏感。</p><p>此刻夜深，老婆孩子都已睡着，计划也已经做定，似乎才缓过神来，可以恢复理智地思考。</p><a id="more"></a><h1 id="是不是过度恐慌了？"><a href="#是不是过度恐慌了？" class="headerlink" title="是不是过度恐慌了？"></a>是不是过度恐慌了？</h1><p>发源于武汉的新型冠状病毒正式命名为SARI，它同SARS是非常类似的病毒。除了致病原理和毒性相似外，其潜伏期更加久，这导致了疾病控制的困难增加。</p><p>看着不断在微信里面传播的各种信息，真消息假消息肯定都有，从这些支离破碎的信息中，我能够感受到的情况是武汉已经非常严重了。加上潜伏期和春运，我个人的悲观估计，春节后会大范围地爆发。</p><p>所以，想到春节就算不回老家，在上海也不可避免需要参与一次的聚餐，还是感到了非常的不适。</p><p>但是，实际上，对于我来说，感染的风险还是很低的，为此，我牺牲了回家团圆的机会，想想是不理智了。</p><h1 id="关于疫情早期的瞒报"><a href="#关于疫情早期的瞒报" class="headerlink" title="关于疫情早期的瞒报"></a>关于疫情早期的瞒报</h1><p>武汉的官员，已经注定被钉在耻辱柱上了。不过，他们也只不过是倒霉的人，换做其他城市的官员，大抵也不过如此。</p><p>你实在是想不明白，这样的信息有什么好隐瞒和压制的。他们或许不是故意的，但是，这些基因早就写在了骨子里，不是这样基因的人根本做不到这样的位置。</p><p>我曾经已经和自己和解，这样的体制，大家好好赚钱就好了。关于专制和腐败成本和民主的社会成本，我觉得是可以算的过来的。但是一到了这种关乎生死的时刻，你才发行，还是不行。</p><p>或许，这样的心情会过去。希望，疫情也早些过去。</p><p>但是如何再与自己和解？</p><h1 id="关于众志成城"><a href="#关于众志成城" class="headerlink" title="关于众志成城"></a>关于众志成城</h1><p>好消息是，一旦这个国家不得不重视起来的时候，做事情的效率也是非常的快。看着各地的医生志愿（或不得已）奔赴疫情前行，我心里还是非常的敬佩的。同时也生出非常的羞愧情绪。</p><p>希望疫情能够得到控制，希望2020年能够一切顺利。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;传染病的季节，怕死的人该如何自处？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过了两天的纠结与折腾，终于决定了取消回家的计划。随着疫情的不断变化加剧，从坐火车到开车到取消，实在是让人心累。&lt;/p&gt;
&lt;p&gt;不知道是有了宝宝之后怕死还是自己原来就这么怕死，但是对于这次的疫情，我表现出了异常的敏感。&lt;/p&gt;
&lt;p&gt;此刻夜深，老婆孩子都已睡着，计划也已经做定，似乎才缓过神来，可以恢复理智地思考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>为EOS小白用户准备的应用：Easy Pay</title>
    <link href="http://yoursite.com/2019/11/21/2019-11-21-EASY-PAY-EOS/"/>
    <id>http://yoursite.com/2019/11/21/2019-11-21-EASY-PAY-EOS/</id>
    <published>2019-11-21T03:14:32.522Z</published>
    <updated>2019-11-21T04:58:55.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>普通用户是否需要了解 EOS 的资源模型？</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>EIDOS 的空投导致整个 EOS 网络交易费用高企，大量用户抵押 EOS 不够发起交易，用户怨声载道。是否 EOS 的资源模型设计存在问题，又有什么办法可以解决这样的问题？</p><a id="more"></a><h1 id="EOS-资源模型"><a href="#EOS-资源模型" class="headerlink" title="EOS 资源模型"></a>EOS 资源模型</h1><p>EOS 的资源模型涉及到</p><ul><li>CPU</li><li>NET</li><li>RAM</li></ul><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p>用来存储用户的数据，比如账户余额，合约数据等。</p><p>RAM 需要向系统购买，不用的时候可以出售还给系统。</p><p>什么时候需要消耗 RAM？比如你给一个用户转账一个代币，而用户原来没有这个代币，那么对方就需要一个快新的空间来存储余额，这个时候，就需要消耗 RAM。</p><p>而在一般的交易中，无需关心 RAM。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>每一笔交易，都需要节点执行并验证，CPU 资源就是与节点的计算时间相对应，每笔交易需要消耗一定的 CPU 时间。</p><p>CPU 资源通过向系统抵押 EOS 来获得，CPU 消耗过后，会在 3 天时间内逐渐恢复。</p><p>抵押一定数量的 EOS 获得的 CPU 时长是动态的，根据全网的使用量动态调节。全网使用量越大，单位 EOS 获得的 CPU 时长越少。</p><h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>每一笔交易，需要传输到节点并且存储在区块中，NET 资源对应的是网络传输和存储的成本，每笔交易需要消耗一定的 NET 使用量。NET 和 CPU 相似，采用抵押获得。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>NET 资源目前是非常宽裕的，而 RAM 资源一般不产生变化，所以主要的问题是 CPU 资源的问题。</p><p>和 BTC、ETH 资源模型不同，前者只要支付交易手续费，就可以等待交易被打包。区别在去交易成功的快慢问题，所以在交易量大的时候，交易成功会延迟。这就是俗称的区块链网络拥堵。</p><p>而在 EOS 中，不存在拥堵的情况，交易如果是合法的，马上就会成功。那么什么是“EOS”的网络拥堵呢？</p><p>那就是用户抵押的 EOS 所获得的 CPU 资源，不够发一笔交易，需要等到全网负荷减少，从而能够分配到足够的 CPU 资源来发起交易。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>从上面的描述，可以得到的结论是，EOS 的资源模型，虽然有着看似免费的概念，但是事实是复杂的，且存在一些缺陷。</p><h2 id="CPU-死锁"><a href="#CPU-死锁" class="headerlink" title="CPU 死锁"></a>CPU 死锁</h2><ul><li>如何获得更多的 CPU 资源？</li><li>通过抵押更多的 EOS</li><li>如何发起抵押操作？</li><li>需要足够的 CPU 资源</li></ul><p>是不是死锁了？没有 CPU 资源什么都做不了。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>他人帮助，有足够多的 CPU 资源的用户，可以帮助抵押 EOS 来获取资源。缺点：<strong>麻烦</strong></li><li>法币租赁，第三方服务商通过收取法币，为用户抵押 EOS 来获取资源。缺点：<strong>昂贵</strong></li></ul><h2 id="空闲浪费"><a href="#空闲浪费" class="headerlink" title="空闲浪费"></a>空闲浪费</h2><p>普通用户，抵押了 EOS 获得了 CPU 资源，常常是空闲不用的，那么这就产生了一种浪费，也降低了资产的流动性。</p><ul><li>抵押足够多：随时可发起交易，多数时间空闲，<strong>浪费</strong></li><li>抵押小：网络负荷低时可以发起交易，网络负荷高无法发起交易，<strong>头疼</strong></li></ul><h1 id="Easy-Pay"><a href="#Easy-Pay" class="headerlink" title="Easy Pay"></a>Easy Pay</h1><p>那有什么办法来解决目前 EOS 资源模型存在的问题？</p><p>EOS 最新的系统升级，引入了一个新特性，就是他方付 CPU 的特性。一笔交易，CPU 资源可以不从交易发起者扣除，而是指定其他账户扣除。</p><p>这样的特性为文本所介绍的应用带来的可能。</p><p>在 Easy Pay 中转账，用户不用给自己抵押 EOS、也不用关心网络的负荷，只需要支付 0.01 EOS 的手续费，就可以马上把交易发出去。CPU 资源由应用方来为用户支付。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>简单易懂</li><li>无需抵押，为资产提供更高的流动性</li><li>无论网络负荷多数，都可以第一时间将交易发送出去</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>Easy Pay 目前支持</p><ul><li>EOS 转账</li><li>EOS 网络中的代币转账，如 LC</li><li>EOS 通用合约调用</li></ul><p>即将上线的功能：</p><ul><li>EOS 糖果抓取</li><li>CPU、NET、RAM 等资源管理</li><li>REX 租赁</li><li>其他常用的功能</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>目前 Easy Pay 已经上线 麦子、Meet One、TokenPocket、ONE 等 EOS 钱包，在这些钱包的应用中都可以搜索到，使用界面简单易懂。</p><p>唯一需要关心的是手续费金额，默认是简单交易 0.01 EOS，一般的转账都是没有问题。如果有复杂的合约调用、领取空投、账号创建等交易。如果使用简单交易超时报错，可以选择复杂交易，需要支付 0.05 EOS。</p><p>文章原创首发<a href="https://lichang.io/otherShow/890" target="_blank" rel="noopener">力场</a></p><p><img src="/img/easy-pay/easypay.jpg" alt="界面"><br><img src="/img/easy-pay/math.jpeg" alt="钱包"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;普通用户是否需要了解 EOS 的资源模型？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;EIDOS 的空投导致整个 EOS 网络交易费用高企，大量用户抵押 EOS 不够发起交易，用户怨声载道。是否 EOS 的资源模型设计存在问题，又有什么办法可以解决这样的问题？&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>基于三角Swap的去中心化做空机制</title>
    <link href="http://yoursite.com/2019/11/09/2019-11-09-DEFI-SHORT-SWAP/"/>
    <id>http://yoursite.com/2019/11/09/2019-11-09-DEFI-SHORT-SWAP/</id>
    <published>2019-11-09T01:12:46.720Z</published>
    <updated>2019-11-21T04:55:18.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无抵押、不爆仓的做空机制是否可能？</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>做空是最常用的金融工具之一，而目前还没有出现成熟的去中心化做空的机制。其中一个重要的原因在于预言机机制不成熟，导致爆仓的时效性无法得到保证。</p><p>本文尝试讨论一种无需抵押和爆仓的做空机制，这样就可以不受目前预言机等技术限制的影响。</p><a id="more"></a><p>该想法最早来源于 aiden pearce 的算法稳定币 VUSD 的设计。但是，我认为他用错了地方，算法稳定币目前来看，还是空中楼阁，看不到实现的可能。但是这个机制用在去中心化交易所的做空机制上，可能是个不错的尝试。</p><h1 id="triswap"><a href="#triswap" class="headerlink" title="triswap"></a>triswap</h1><p>uniswap 是一个经过时间考验，非常成熟好用的去中心化交易协议。它通过交易对的底仓形成价格和深度，为交易者提供即刻的流动性。</p><p>假设一个基于 uniswap 模型的 EOS/USDT 交易对，在交易对中引入一个做空权益代币，short-EOS，简称 sEOS。在对底仓注入交易对两边的资金同时，根据 EOS/sEOS 的价格发行相同价值的做空权益 sEOS。让交易对中的 EOS、sEOS 和 USDT 形成三角的 uniswap，这里简称 triswap。</p><p>3 个币种会自然形成 3 个交易对，分别是 EOS/USDT、sEOS/USDT、EOS/sEOS，根据 uniswap 的模型，价格来源于币种在底仓中余额的比值，而这 3 个交易对共享底仓中 3 个余额。所以每个交易对发生交易后，对其他 2 个交易对的价格也会产生直接的影响。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>初始 0 底仓，交易对补充 10000 USDT 和 5000 EOS 形成交易对。</li><li>EOS/sEOS 交易对在实际情况中会有市场价格，在初始阶段，需要对 sEOS 拟定一个价格</li><li>例子假设 EOS/sEOS = 1/10</li><li>补充底仓的同时新增发行同等价值的 50000 sEOS</li><li>初始价格：EOS：2 U ， sEOS：0.2 U</li><li>以下举例都由最初的底仓展开，交易资金量为底仓 1%</li><li>3 个交易对有 6 中交易行为</li></ul><h3 id="USDT-gt-EOS"><a href="#USDT-gt-EOS" class="headerlink" title="USDT-&gt;EOS"></a>USDT-&gt;EOS</h3><p>100 USDT -&gt; 49.5 EOS</p><p>交易后：</p><ul><li>EOS/USDT： 2.04， 上涨 4%</li><li>sEOS/USDT： 0.202，上涨 2% （同时上涨）</li><li>sEOS/EOS： 0.099，下降 1%</li></ul><h3 id="EOS-gt-USDT"><a href="#EOS-gt-USDT" class="headerlink" title="EOS-&gt;USDT"></a>EOS-&gt;USDT</h3><p>50 EOS -&gt; 99.01 USDT</p><p>交易后：</p><ul><li>EOS/USDT： 1.96， 下跌 4%</li><li>sEOS/USDT： 0.198， 下跌 2% （同时下跌）</li><li>sEOS/EOS： 0.101， 上涨 1%</li></ul><h3 id="USDT-gt-sEOS"><a href="#USDT-gt-sEOS" class="headerlink" title="USDT-&gt;sEOS"></a>USDT-&gt;sEOS</h3><p>100 USDT -&gt; 495.05 sEOS</p><p>交易后：</p><ul><li>EOS/USDT： 2.02， 上涨 2%</li><li>sEOS/USDT：0.0204，上涨 4%</li><li>sEOS/EOS： 0.101， 上涨 1%</li></ul><h3 id="sEOS-gt-USDT"><a href="#sEOS-gt-USDT" class="headerlink" title="sEOS-&gt;USDT"></a>sEOS-&gt;USDT</h3><p><em>初始情况不存在可以卖出的 sEOS，此处假设</em></p><p>500 sEOS -&gt; 99.01 USDT</p><p>交易后：</p><ul><li>EOS/USDT： 1.98， 下跌 2%</li><li>sEOS/USDT：0.196，下跌 4%</li><li>sEOS/EOS： 0.099，下降 1%</li></ul><h3 id="EOS-gt-sEOS"><a href="#EOS-gt-sEOS" class="headerlink" title="EOS-&gt;sEOS"></a>EOS-&gt;sEOS</h3><p>50 EOS-&gt; 495.05 sEOS</p><p>交易后：</p><ul><li>EOS/USDT： 1.98 ，下降 1%</li><li>sEOS/USDT：0.202，上涨 1%</li><li>sEOS/EOS： 0.102，上涨 2%</li></ul><h3 id="sEOS-gt-EOS-卖出平空"><a href="#sEOS-gt-EOS-卖出平空" class="headerlink" title="sEOS-&gt;EOS 卖出平空"></a>sEOS-&gt;EOS 卖出平空</h3><p><em>初始情况不存在可以卖出的 sEOS，此处假设</em></p><p>500 sEOS-&gt; 49.5 EOS</p><p>交易后：</p><ul><li>EOS/USDT： 2.02 ， 上涨 1%</li><li>sEOS/USDT：0.0198 ，下跌 1%</li><li>sEOS/EOS： 0.098 ， 下跌 2%</li></ul><h1 id="做空逻辑"><a href="#做空逻辑" class="headerlink" title="做空逻辑"></a>做空逻辑</h1><ul><li>认为 EOS 价格会下跌，用 EOS 买入 sEOS</li><li>EOS/USDT 价格下跌，普通用户、套利用户会卖出 EOS</li><li>如果交易 EOS-&gt;USDT，sEOS/USDT 价格下跌幅度为 EOS/USDT 的一半，sEOS 相对 EOS 的价格上涨</li><li>如果交易 EOS-&gt;sEOS，同样能够使 EOS/USDT 下降以匹配价差，此时，sEOS 相对 EOS 价格的涨幅是交易额的 2 倍</li><li>认为下跌行情结束，用 sEOS 买回 EOS，可以获得相对购买时更多的 EOS</li></ul><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>sEOS 无需其他资产抵押</li><li>sEOS 没有爆仓</li><li>sEOS 只有最后兑现成 EOS 才能完成做空的盈利，sEOS 对 USDT 不会产生做空盈利</li><li>这是一个赚币的做空方案</li><li>无杠杆，波动相对小</li></ul><h1 id="产品化方案"><a href="#产品化方案" class="headerlink" title="产品化方案"></a>产品化方案</h1><ul><li>在 uniswap 的币币兑换的基础上增加“币做空”</li><li>“币做空”交易 EOS/sEOS</li><li>考虑到 sEOS/USDT 对于 EOS/USDT 并不是反向的作用，可以禁用 USDT-&gt;sEOS ，只允许 sEOS-&gt;USDT 的权益兑现</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>全文以 USDT、EOS、sEOS 举例，可以适用于任何交易对。但是在 unsiwap 多交易对拼接形成的交易对中，可能效果会不同。</p><p>sEOS 的发行是对底仓注资的同时。所以，在底仓取回的同时，也会根据当时的 EOS/sEOS 价格销毁相同价值的 sEOS</p><p>EOS/sEOS 的价格，是一个市场博弈的结果，对于什么价格是合理的，我目前也没有想通。如果想通了可以再写一篇。</p><p>这个想法还是很粗糙，欢迎大家一起讨论。</p><p>文章原创首发<a href="https://lichang.io/articleDetail/931431" target="_blank" rel="noopener">力场</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;无抵押、不爆仓的做空机制是否可能？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;做空是最常用的金融工具之一，而目前还没有出现成熟的去中心化做空的机制。其中一个重要的原因在于预言机机制不成熟，导致爆仓的时效性无法得到保证。&lt;/p&gt;
&lt;p&gt;本文尝试讨论一种无需抵押和爆仓的做空机制，这样就可以不受目前预言机等技术限制的影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="uniswap" scheme="http://yoursite.com/tags/uniswap/"/>
    
      <category term="Defi" scheme="http://yoursite.com/tags/Defi/"/>
    
      <category term="去中心化金融" scheme="http://yoursite.com/tags/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E9%87%91%E8%9E%8D/"/>
    
      <category term="dex" scheme="http://yoursite.com/tags/dex/"/>
    
      <category term="去中心化交易所" scheme="http://yoursite.com/tags/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E4%BA%A4%E6%98%93%E6%89%80/"/>
    
  </entry>
  
  <entry>
    <title>EIDOS，一场早就分出胜负的游戏</title>
    <link href="http://yoursite.com/2019/11/04/2019-11-04-EIDOS-FOMO/"/>
    <id>http://yoursite.com/2019/11/04/2019-11-04-EIDOS-FOMO/</id>
    <published>2019-11-04T10:53:00.000Z</published>
    <updated>2019-11-21T04:54:53.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>EIDOS - ENUMIVO IS DEAD, OH SHIT!</p></blockquote><h1 id="0-撸的魅力"><a href="#0-撸的魅力" class="headerlink" title="0 撸的魅力"></a>0 撸的魅力</h1><p>一个币，开盘就上线 Bithumb，完全没有付上币费，Hoo、MXC、BKEX、BIKI、Newdex、WhaleEX。。。。抢着上架。这就是热度的价值，这就是 0 撸的魅力。</p><a id="more"></a><p>币圈最不缺的就是羊毛党。</p><p>EIDOS 这个项目，只要你往合约地址转账任意金额的 EOS，你就能获得 1/10000 新增产量的 EIDOS，并且 EOS 也会还给你。</p><p>EIDOS 总量 10 亿，1 年半发行完，20%的发行量给团队。</p><p>11 月 1 号下午 4 点开始，当天早上在区块律动和 dapp 社区的宣传下，引发了大量的关注。</p><p>很多用户都去撸了，很快，EOS 的交易量就上来了，很快 EOS 的 CPU 价格就被推高了，普通用户的可怜的 0.1 EOS 的资源抵押可能连 1 次交易都不能发起。</p><p>这个时候轮到 MYKEY 表演了，MYKEY 是一个 EOS 的（半）中心化钱包，很难准确的定义。MYKEY 帮助用户支付 CPU 成本，让用户继续 0 撸，一时间大量用户涌入 MYKEY，就一个晚上就把 MYKEY 原来的资源撸爆，MYKEY 紧急维护。维护之后限制用户每分钟只能撸一次。</p><p>同一时间在 TokenPocket 上，撸币矿机（帮助用户更快撸币的工具），包括 Win96 矿机 dapp 都第一时间支持 EIDOS。</p><p>所有这些的结果就是，EOS 链 CPU 价格攀升，普通用户无法交易。给币圈的感官是 EOS 又堵了，EOS 又爆了。</p><p>当然，这个认识是错误，EOS 是高速公路，保证快速交易的同时，因为 CPU 价格调节机制阻挡了低价交易。关于 EOS 费用模型可以单读开一篇，这个不多说。好在 EOS 的新特性可以优化目前的问题。</p><h1 id="胜负早已决定"><a href="#胜负早已决定" class="headerlink" title="胜负早已决定"></a>胜负早已决定</h1><p><strong>这部分是本文的核心。</strong></p><p>EIDOS 的分发，看似是长达 1 年半的游戏。但是实际上，在第一天就决定了各个参与方的优势所在。</p><p>EIDOS 的分发，比拼 CPU 的数量，你拥有更多的 CPU 时间你就能获得更多的币。</p><p><strong>本质上，比拼的是 CPU 的成本。</strong></p><p>这里普及一下 REX（EOS 系统级资源交易所），用户可以将没用的 EOS 存入 REX 产生收益，需要资源的用户可以向 REX 租 EOS 资源。</p><p>11 月 1 号下午 5 点，我向 REX 支付 40 个 EOS，换取了 130331 EOS 对应的资源的 30 天使用权，价格是 3200 EOS-CPU/EOS。</p><p>而现在，11 月 4 号下午 6 点，REX 的价格是 188 EOS-CPU/EOS。</p><p>什么概念，新矿工的挖矿成本是我的 17 倍。</p><p>更夸张的是，第一天租赁 CPU 的矿工，当天就回本了！而且他还可以挖 29 天。</p><p>所以说，那些散户矿工和后来租赁 EOS 的矿工很可能辛辛苦苦，最后不能回本。因为你面对的是技术比你牛，成本比你低的专业玩家。</p><h1 id="不是傻就是坏"><a href="#不是傻就是坏" class="headerlink" title="不是傻就是坏"></a>不是傻就是坏</h1><p>我已经在上一篇文章中介绍了 AP，这个匿名创始人因为认为 ENU 分配机制不公平导致大户垄断整条链的男人，声称他这次使用了公平的方式去分发 EIDOS。</p><p><strong>这样的人，不是傻就是坏！</strong></p><p>当然他一点都不傻。</p><h1 id="模式创造者"><a href="#模式创造者" class="headerlink" title="模式创造者"></a>模式创造者</h1><p>两次代币发行都引起巨大的舆论关注和热度，不得不承认，AP 这个人有点厉害。他是一个很好的模式创造者。ENU 的分发带起了空抓的概念。而这次 EIDOS 的发行，不断地酝酿。至少已经出现了 POS 云矿机等新的概念。而有新的玩法对这个圈子就是好事情，我同意小岛的说法，这个事件实际利好 EOS，因为有不同的玩法出现了。</p><h1 id="CODEX"><a href="#CODEX" class="headerlink" title="CODEX"></a>CODEX</h1><p>昨天晚上，AP 公布了 EIDOS 这个空气的价值，它将成为 CODEX 的平台币。而 CODEX 这个 DEX 有什么特别的地方吗？</p><p><strong>然鹅并没有</strong></p><p>CODEX 就是 UNISWAP 的一个复制。UNISWAP 可以看我之前文章的介绍。</p><p>AP 这个男人，我们戏称他 FORK MAN，LiteShares fork BitShares，ENU fork EOS，CODEX fork UNISWAP。</p><p>除了 Fork，他还会什么？</p><h1 id="EOS-堵的假象"><a href="#EOS-堵的假象" class="headerlink" title="EOS 堵的假象"></a>EOS 堵的假象</h1><p>我还是要为 EOS 辩驳几句，EOS 的堵是假象。</p><p>只要你有足够的资源，你还是可以秒到账，而没有资源交易都不能成功。</p><p>当全网交易量增大后，资源价格的自动调节机制，导致资源抵押不够的用户无法发起交易。</p><p>目前社区有各种资源租赁的方案可以部分解决这个问题。</p><p>最新的他方付费机制，能够更好地解决这个问题。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这个项目最终会归零，但是过程会是怎么样，谁也不知道，每个人自己把握吧。</p><p>文章原创首发<a href="https://lichang.io/articleDetail/911639" target="_blank" rel="noopener">力场</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;EIDOS - ENUMIVO IS DEAD, OH SHIT!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;0-撸的魅力&quot;&gt;&lt;a href=&quot;#0-撸的魅力&quot; class=&quot;headerlink&quot; title=&quot;0 撸的魅力&quot;&gt;&lt;/a&gt;0 撸的魅力&lt;/h1&gt;&lt;p&gt;一个币，开盘就上线 Bithumb，完全没有付上币费，Hoo、MXC、BKEX、BIKI、Newdex、WhaleEX。。。。抢着上架。这就是热度的价值，这就是 0 撸的魅力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链轶事" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%BD%B6%E4%BA%8B/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EIDOS" scheme="http://yoursite.com/tags/EIDOS/"/>
    
      <category term="AP" scheme="http://yoursite.com/tags/AP/"/>
    
  </entry>
  
  <entry>
    <title>EIDOS撸爆EOS，说说我和ENU以及AP的故事</title>
    <link href="http://yoursite.com/2019/11/04/2019-11-04-ENU-AP-ME/"/>
    <id>http://yoursite.com/2019/11/04/2019-11-04-ENU-AP-ME/</id>
    <published>2019-11-04T02:01:00.000Z</published>
    <updated>2019-11-21T04:55:07.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不要接盘！不要接盘！不要接盘！重要的事情说三遍</p></blockquote><p>EIDOS 空投已经成为这个周末币圈最热的话题之一，“0 成本”挖矿吸引了一波用户关注。因为大量的撸币交易，导致 EOS 主网 CPU 价格不断攀升，大量用户的 EOS 资源都不够去发起一笔交易。</p><p>关于 EOS 的资源模型所存在的问题，可以单独写一篇文章，这里就暂时不展开。好消息是，因为 EOS 主网刚升级的他方付费的特性，用户使用资源的老大难问题很快会得到解决。</p><p>EIDOS 是 Enumivo（ENU）创始人 aiden pearce（AP）启动的新项目。</p><p>在这篇文章里，我要讲讲我和 ENU 以及 AP 之前的故事。</p><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>时间要回到 2018 年，EOS 主网启动的时候，当时我作为 EOSeco 节点的负责人，全程参与了 EOS 主网启动的过程，同时开发了一款 EOS 区块链浏览器 EOSeco explorer。现在你可能不知道，但是最开始的时候，它还是服务了一些用户，特别是在主网激活阶段，通过离线签名的方式，为用户提供安全的投票操作。后来因为投资人套现 EOS，我们的节点也失去了竞争力，逐渐退出 EOS 节点竞选。在这个过程中，认识了非常多 EOS 圈子的技术大牛。</p><p>后来有个朋友和我说了 ENU，是一个 EOS 的复制链，还没有浏览器工具，让我把浏览器迁移过去。于是，我就在 ENU 上面搭了一个节点，并把浏览器迁移了过去。这个行为得到社区非常热烈的反馈，用户自发众筹感谢浏览器，这让我有些激动。之后，我发现 ENU 社区除了用户活跃之外，也不乏优秀的社区开发者，他们可能原来都不是币圈的用户，而是因为 UBI 的理念参与到这个项目。这里还要特别推荐一下 ENU 上面的一个好玩的趣味 dAPP - 站队 。在 EOS 全都是菠菜 dAPP 的时候，站队玩出了一股清流。因为 EOS 主网启动社区准备了很久，而 ENU 链，甚至比 EOS 主网更早的启动。这些都让我对这个项目产生了一些感情，并且在之后的时间里不断地参与到这个项目当中。</p><p>在这之后，我直接推动了 TP 钱包支持 ENU，在后续的 ENU 钱包和交易所的对接过程中，我几乎是主力的社区技术人员。</p><h2 id="我对-AP-的印象"><a href="#我对-AP-的印象" class="headerlink" title="我对 AP 的印象"></a>我对 AP 的印象</h2><p>熟悉了 ENU 中国社区之后，我也和 AP 取得了直接的联系。AP 是一个匿名的人，你只能在 Telegram 中找到他，他应该是 BTC 和 ETH 的早期投资者，从和他的接触过程中，你能感受到他是一个偏“左”的人，这从 ENU 项目所要做的 UBI（全面基本收入）就可以看出来。其实我自己是个偏“右”的人，不认为这件事情真的能做成，但是这不妨碍我参与其中。经过一段时间的接触，发现 ENU 这个项目除了 AP 自己，没有全职的开发人员，只是在网上雇佣了几个开发者，包括 AP 自己都不算全职。所以除了跟 EOS 的版本更新，几乎没有更多的开发量。而我也作为社区开发者，也帮助做了投票激励和一版 UBI 的原型。但是总体来说，项目的进展非常缓慢，而 UBI 的大饼遥遥无期。</p><h2 id="AP-与社区的矛盾"><a href="#AP-与社区的矛盾" class="headerlink" title="AP 与社区的矛盾"></a>AP 与社区的矛盾</h2><p>与此形成对比的是，ENU 中国社区，靠着社区的力量，以众筹等形式，相继上线 Cointiger、AEX 和 Biki 等交易所，这其中 David 贡献功不可没。这在我看来，真的可以说的币圈的一股清流。</p><p>好景不长，项目进展缓慢，AP 却持续套现来支付开发费用，这导致社区对 AP 产生了很大的意见。而 AP 一边，一直诟病节点的中心化，对于中国社区把持超级节点非常不满。两边的矛盾不断积累，矛盾的爆发只需要一个火星。</p><p>而这个导火索就是 AEX 的交易量，AP 怀疑 AEX 在刷量，认为这会误导持币者，要求 AEX 下架 ENU，同时指出由 5 个节点都是由一个人在控制，要求他退出节点。社区和 AP 已然不可调和，而 AP 最终选择了最激烈的，甚至是行为艺术的方式退出社区。</p><p>目前，ENU 社区也是在苦苦支撑，节点的利润完全不能覆盖成本，为了对社区的一点感情，我也是在持续维持着浏览器。其实，我并不是 ENU 的受益者，在最开始轰轰烈烈的空投以及后来的爆炒都与我无关，所以 AP 的退出，和 ENU 的接近归零对我来说也是很受伤。但是更受伤的是高位接盘的人，ENU 最高的时候到过 1 块钱，而目前的价格是 1 分钱。</p><p>AP 很任性，也很有煽动性，在社区里，还有人在给他造神，甚至说他是中本聪。</p><p>持币者很受伤，甚至是一些大佬。而因为匿名的原因，也没有人找得到他，也没法维权。</p><p>这就是我和 ENU 以及 AP 的一些往事，文笔不行，权当记录。这也是我对 EIDOS 潜在接盘者所能做的一些警告，希望能够帮到他们。</p><p>关于我对 EIDOS 和 CODEX 去中心化交易所的看法，我会再写一篇，敬请期待。</p><p>文章原创首发<a href="https://lichang.io/articleDetail/909965" target="_blank" rel="noopener">力场</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不要接盘！不要接盘！不要接盘！重要的事情说三遍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EIDOS 空投已经成为这个周末币圈最热的话题之一，“0 成本”挖矿吸引了一波用户关注。因为大量的撸币交易，导致 EOS 主网 CPU 价格不断攀升，大量用户的 EOS 资源都不够去发起一笔交易。&lt;/p&gt;
&lt;p&gt;关于 EOS 的资源模型所存在的问题，可以单独写一篇文章，这里就暂时不展开。好消息是，因为 EOS 主网刚升级的他方付费的特性，用户使用资源的老大难问题很快会得到解决。&lt;/p&gt;
&lt;p&gt;EIDOS 是 Enumivo（ENU）创始人 aiden pearce（AP）启动的新项目。&lt;/p&gt;
&lt;p&gt;在这篇文章里，我要讲讲我和 ENU 以及 AP 之前的故事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链轶事" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%BD%B6%E4%BA%8B/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EIDOS" scheme="http://yoursite.com/tags/EIDOS/"/>
    
      <category term="ENU" scheme="http://yoursite.com/tags/ENU/"/>
    
      <category term="AP" scheme="http://yoursite.com/tags/AP/"/>
    
      <category term="enumivo" scheme="http://yoursite.com/tags/enumivo/"/>
    
      <category term="aiden pearce" scheme="http://yoursite.com/tags/aiden-pearce/"/>
    
  </entry>
  
  <entry>
    <title>简述FIBOS DEX撮合模型</title>
    <link href="http://yoursite.com/2019/08/21/2019-08-21-FIBOS-DEX/"/>
    <id>http://yoursite.com/2019/08/21/2019-08-21-FIBOS-DEX/</id>
    <published>2019-08-21T01:58:00.000Z</published>
    <updated>2019-11-09T00:08:27.353Z</updated>
    
    <content type="html"><![CDATA[<p>说说FIBOS DEX如果结合uniswap和挂单的撮合模型</p><a id="more"></a><p>在之前的文章中，已经介绍过 FIBOS 和 FIBOS 的异构跨链体系。随着 FIBOS DEX 的正式上线，我们来聊一聊 FIBOS DEX 到底有什么特别之处。</p><h2 id="传统交易形式"><a href="#传统交易形式" class="headerlink" title="传统交易形式"></a>传统交易形式</h2><p>一般的交易所，包括目前绝大部分的交易所，都是采用「挂单/吃单」的撮合模型。用户可以选择指定的价格买入/卖出特定资产，如果没有匹配的价格，那么这个交易需求会保存在「订单簿」上，这个行为称为「挂单」。直到有用户选择「市价买入」或者挂一个新单能够匹配目前「订单簿」的价格，那么就会把之前的挂单与新的挂单进行撮合成交，这个行为称为「吃单」。</p><p>这种交易撮合模式是符合直觉的，也是目前主流的交易撮合模式。那么这样的模式有什么问题呢？</p><p>我们在一些小的交易所或者小的币种的对一对经常会看到，如果挂单的「深度」不够，如果你现在就想梭哈或者抛售，往往不可能，如果深度不够，可以会「拉爆」或者「砸穿」。这是一些新手大户会遇到的问题，如果习惯了市价吃单，或者挂错价格，那可能会得到意想不到的后果。</p><p>对于买卖方意愿都不足的市场，挂单的撮合模型存在「流动性」问题。</p><p>那么，除了挂单的撮合模型，还有哪些撮合模型呢？</p><h2 id="uniswap"><a href="#uniswap" class="headerlink" title="uniswap"></a>uniswap</h2><p>这个撮合模型我们在之前的文章中也有提到过，它是一个自动成交的交易模型。你不需要等人和你进行价格匹配，立马就可以成交。所有的交易都是「吃单」的行为，那么吃谁的单？以什么价格成交呢？</p><p>在 uniswap 中，有底池的概念，底池中分别有交易对的两个币种，底池就是交易对手方。那么又是以什么价格同底池进行交易呢？</p><p>底池中两个币种的比例就是目前的价格，比如底池用有 10 个 USDT，1000 个 FO，那么目前 FO 的价格就是 0.01 USDT。那么当你进行购买操作的时候，是不是都以 0.01 的价格成交呢？并不是这样的。</p><p>在公式中，要求交易前后有一个等式必须成立：</p><p><strong>交易前底池币种 A _ 交易前底池币种 B = 交易后底池币种 A _ 交易后底池币种 B</strong></p><p>假如我们用 A 来购买 B，进一步推导：</p><p><strong>交易前底池币种 A _ 交易前底池币种 B = （交易前底池币种 A+购买所付出的币种 A）_（交易前底池币种 B-买到的币种 B）</strong></p><p>再进行简化：</p><p><strong>买到的币种 B = 交易前底池币种 B -（交易前底池币种 A * 交易前底池币种 B）/（交易前底池币种 A+购买所付出的币种 A）</strong></p><p>是不是已经晕了？我们举个例子。</p><p>底池用有 10 个 USDT，1000 个 FO，我用 1USDT 来购买 FO。</p><p>买到的 FO = 1000 - 10*1000/（10+1） ≈ 90.9，成交的价格为 0.011。</p><p>是的，价格不是 0.01 而是 0.011。这就是 uniswap 的特点，每次交易都会造成价格的变化，如果买了价格就会变多，如果卖了价格就会变低。而交易金额相对底仓越多，就会造成越大的价格变化。</p><p>为了避免价格的剧烈变动，就必须保持底仓的金额足够多。除了交易之外，还可以对底仓进行加仓或者减仓。使用当前的市价，为底仓注入同等价值的代币。这样，在不变动价格的情况下，就可以增加底仓的金额。这样，一般的交易者就可以用更好的价格进行交易。</p><p>而底仓的资金也都是来自用户，那用户把资金加入底仓有什么好处呢？底仓用户可以瓜分交易的手续费。那么底仓资金有什么风险呢？如果市场形成单边行情，比如一直涨，那么底仓中的 USDT 就会增多，而 FO 就会减少。如果哪天你要从底仓中拿出你的资金，你会发现，USDT 多了而 FO 少了，而按照目前的价格，多出来的 USDT 买不到少掉的 FO，其实你就是变相在价格升高的过程中把 FO 卖给其他用户。</p><p>uniswap 模型适合希望立即成交的用户，但是问题是，你无法用你期待的价格进行成交。</p><h2 id="FIBOS-DEX"><a href="#FIBOS-DEX" class="headerlink" title="FIBOS DEX"></a>FIBOS DEX</h2><p>说到这里，终于可以介绍 FIBOS DEX 了，它结合了 uniswap 和挂单两种撮合模型。如果你愿意等，你可以挂单，等待特定的价格进行撮合。如果你不愿意等，希望立即成交，你也可以通过 uniswap 模型，直接与底仓交易。除此之外，你还可以充值底仓，通过提供流动性来赚取手续费。</p><p>除此之外，FIBOS DEX 其实是一个「协议」而不是具体的交易所，因为所有的交易对都是用户自行创建，底层也是用户来进行维护。交易手续费归属底仓用户，没有所谓的项目方收取手续费。更重要的是，资产完全由用户自己保管，不存在交易所被盗的风险。</p><p>文章原创首发<a href="https://lichang.io/articleDetail/563924" target="_blank" rel="noopener">力场</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说说FIBOS DEX如果结合uniswap和挂单的撮合模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="FIBOS" scheme="http://yoursite.com/tags/FIBOS/"/>
    
      <category term="DEX" scheme="http://yoursite.com/tags/DEX/"/>
    
      <category term="uniswap" scheme="http://yoursite.com/tags/uniswap/"/>
    
  </entry>
  
  <entry>
    <title>EOSIO随机数的一种实现</title>
    <link href="http://yoursite.com/2019/03/11/2019-3-12-EOS-RANDOM/"/>
    <id>http://yoursite.com/2019/03/11/2019-3-12-EOS-RANDOM/</id>
    <published>2019-03-11T12:07:00.000Z</published>
    <updated>2019-11-21T04:56:12.405Z</updated>
    
    <content type="html"><![CDATA[<p>最近帮助 Enumivo（基于 EOSIO）社区做一个投票奖励活动，除了基本的投票奖励之外，还加入了一定的随机机制，增加乐趣。</p><a id="more"></a><h2 id="合约随机逻辑："><a href="#合约随机逻辑：" class="headerlink" title="合约随机逻辑："></a>合约随机逻辑：</h2><ol><li><p>用户发起领取交易，领取投票奖励，同时合约账户转 1ENU 到奖池，同时发起一笔（0-24 小时随机值）的延迟交易。</p></li><li><p>延迟交易被触发，检查奖池金额，达到了 10ENU，就把 10ENU 都奖励给当前用户。</p></li></ol><h2 id="随机机制："><a href="#随机机制：" class="headerlink" title="随机机制："></a>随机机制：</h2><p>0-24 小时这个时间的随机数，就使用之前常用的利用 block prefix 值来生成，这个不是随机的唯一部分。因为就算用户可以控制随机数来控制延迟时间，也没有办法控制延迟交易发生时奖池的金额，奖池的金额完全是根据其他用户的随机行为来进行累积的。利用这样的随机数方案，或许能够开发一款公平的 Lottery Dapp。</p><h2 id="可能的攻击方式："><a href="#可能的攻击方式：" class="headerlink" title="可能的攻击方式："></a>可能的攻击方式：</h2><p>构造交易控制随机数控制延时时间，在延迟交易发生前利用别的账户发起交易，将奖池金额构造到满足开奖条件。像本应用这样金额比较小的开奖，应该没有人会费时费力做这个事情。当奖金足够诱人的时候，就有人和你竞争，增加了开奖的不确定性。</p><p>欢迎拍砖。</p><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><ul><li><p>合约交易历史：<a href="http://enumivo.qsx.io/search?q=claimlottery" target="_blank" rel="noopener">http://enumivo.qsx.io/search?q=claimlottery</a></p></li><li><p>合约开源地址：<a href="https://github.com/ENU-Zion/claimforvote" target="_blank" rel="noopener">https://github.com/ENU-Zion/claimforvote</a></p></li></ul><h2 id="Enumivo"><a href="#Enumivo" class="headerlink" title="Enumivo"></a>Enumivo</h2><p>Enumivo 是一个以 UBI（全民基本收入）为目标的区块链项目</p><p>白皮书：</p><p><a href="https://enumivo.org/whitepapers/whitepaper_cn.pdf" target="_blank" rel="noopener">https://enumivo.org/whitepapers/whitepaper_cn.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近帮助 Enumivo（基于 EOSIO）社区做一个投票奖励活动，除了基本的投票奖励之外，还加入了一定的随机机制，增加乐趣。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>EOSIO Dawn 4.0 系统合约解读</title>
    <link href="http://yoursite.com/2018/05/17/2018-5-17-EOS-SYSTEM-CONTRACT/"/>
    <id>http://yoursite.com/2018/05/17/2018-5-17-EOS-SYSTEM-CONTRACT/</id>
    <published>2018-05-17T05:07:00.000Z</published>
    <updated>2019-11-21T04:56:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>Dawn 4.0 发布后，基本上白皮书上提到的特性都得到了实现，特别是投票、资源抵押和内存买卖。</p><p>EOS 的网络带宽和计算资源是通过抵押代币的方式获得，如果不需要了可以解除抵押收回原先的代币。</p><p>投票的权重和抵押代币所获得的带宽和计算资源相关，抵押了越多，投票的权重越大。同时投票的权重会随着时间的推移减少，这个设定鼓励用户持续更新自己的投票。</p><p>而存储资源则是通过购买来得到，但是并不会消耗，当不再需要存储资源的时候可以出售。但是存储资源相对于 EOS 代币的价格会随着市场对于存储资源的需求而变动。</p><p>而这些功能都是在 eosio.system 这个智能合约中实现。</p><p>本文试图通过分析 eosio.system 中所有的功能函数来解读 eos 系统功能。</p><a id="more"></a><h2 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h2><p>在 eosio.system.hpp 头文件中包含以下函数声明：</p><h3 id="delegatebw"><a href="#delegatebw" class="headerlink" title="delegatebw"></a>delegatebw</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onblock</span><span class="params">( block_timestamp timestamp, account_name producer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delegatebw</span><span class="params">( account_name from, account_name receiver,asset stake_net_quantity, asset stake_cpu_quantity, <span class="keyword">bool</span> transfer )</span></span>;</span><br></pre></td></tr></table></figure><p>delegatebw 函数用来实现抵押代币获取 cpu 和带宽资源。参数定义：</p><ul><li>from : 从哪个账号扣除用来抵押的代币</li><li>receiver : 抵押的代币的接受者，表示抵押获取的资源作用在哪个账号上</li><li>stake_net_quantity : 用来抵押带宽资源的代币数量</li><li>stake_cpu_quantity : 用来抵押计算资源的代币数量</li><li>transfer : 是否接受者可以主动解除抵押获得代币，如果不是，只有发起者能够解除抵押收回代币</li></ul><h3 id="undelegatebw"><a href="#undelegatebw" class="headerlink" title="undelegatebw"></a>undelegatebw</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undelegatebw</span><span class="params">( account_name from, account_name receiver,asset unstake_net_quantity, asset unstake_cpu_quantity )</span></span>;</span><br></pre></td></tr></table></figure><p>undelegatebw 函数用来解除抵押，释放资源，收回代币，参数定义：</p><ul><li>from : 解除用哪个账号所抵押的代币</li><li>receiver : 解除作用在哪个账号上的抵押代币</li><li>unstake_net_quantity : 解除用来获取带宽资源的代币数量</li><li>unstake_cpu_quantity : 解除用来获取计算资源的代币数量</li></ul><p>解除抵押之后，资源会马上释放，同时投票权重也相应消失。但是代币需要等待一定时间才能回到账号里，目前  的设定是 3 天。</p><h3 id="buyram"><a href="#buyram" class="headerlink" title="buyram"></a>buyram</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buyram</span><span class="params">( account_name buyer, account_name receiver, asset tokens )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buyrambytes</span><span class="params">( account_name buyer, account_name receiver, <span class="keyword">uint32_t</span> bytes )</span></span>;</span><br></pre></td></tr></table></figure><p>这两个函数的作用是购买存储资源，区别是买特定数量的代币还是买特定大小的内容。参数定义:</p><ul><li>buyer : 购买存储资源的账号</li><li>receiver : 接受存储资源的账号</li><li>tokens : 购买存储资源所用的代币数量</li><li>bytes : 都买存储资源空间大小的数值</li></ul><h3 id="sellram"><a href="#sellram" class="headerlink" title="sellram"></a>sellram</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sellram</span><span class="params">( account_name receiver, <span class="keyword">int64_t</span> bytes )</span></span>;</span><br></pre></td></tr></table></figure><p>sellram 函数功能是出售不需要的存储资源。参数定义：</p><ul><li>receiver : 出售资源代币的接受账号</li><li>bytes : 出售多少空间的存储资源</li></ul><p>出售后资源会马上释放，收入的代币也会马上入账。</p><h3 id="refund"><a href="#refund" class="headerlink" title="refund"></a>refund</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refund</span><span class="params">( account_name owner )</span></span>;</span><br></pre></td></tr></table></figure><p>refund 函数 在 undelegatebw 函数解除抵押后调用，作用是把抵押的代币退回账户。</p><h3 id="regproducer"><a href="#regproducer" class="headerlink" title="regproducer"></a>regproducer</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">regproducer</span><span class="params">( <span class="keyword">const</span> account_name producer, <span class="keyword">const</span> public_key&amp; producer_key, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; url, <span class="keyword">uint16_t</span> location )</span></span>;</span><br></pre></td></tr></table></figure><p>regproducer 函数的作用是注册成为超级节点候选人。参数定义：</p><ul><li>producer : 候选节点的账户名</li><li>producer_key : 候选节点的账户公钥</li><li>url : 候选节点的网站地址</li><li>location : 候选节点的机房地理位置</li></ul><p>注册成为候选人后就可以接受用户的投票了。</p><h3 id="unregprod"><a href="#unregprod" class="headerlink" title="unregprod"></a>unregprod</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregprod</span><span class="params">( <span class="keyword">const</span> account_name producer )</span></span>;</span><br></pre></td></tr></table></figure><p>unregprod 函数的作用的取消成为候选人。</p><h3 id="voteproducer"><a href="#voteproducer" class="headerlink" title="voteproducer"></a>voteproducer</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setram</span><span class="params">( <span class="keyword">uint64_t</span> max_ram_size )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">voteproducer</span><span class="params">( <span class="keyword">const</span> account_name voter, <span class="keyword">const</span> account_name proxy, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;account_name&gt;&amp; producers )</span></span>;</span><br></pre></td></tr></table></figure><p>voteproducer 函数的作用是投票。参数定义：</p><ul><li>voter : 投票人</li><li>proxy : 代理投票人</li><li>producers : 得票人列表</li></ul><p>有两种投票模式，代理模式和直接投票模式。代理模式是将投票权重委托给一个代理人，让他帮你投票。直接投票模式就是直接投票给你信任的超级节点，最多 30 个。</p><h3 id="regproxy"><a href="#regproxy" class="headerlink" title="regproxy"></a>regproxy</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">regproxy</span><span class="params">( <span class="keyword">const</span> account_name proxy, <span class="keyword">bool</span> isproxy )</span></span>;</span><br></pre></td></tr></table></figure><p>regproxy 函数的作用是注册成为代理人，接受其他用户的委托。</p><h3 id="claimrewards"><a href="#claimrewards" class="headerlink" title="claimrewards"></a>claimrewards</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">claimrewards</span><span class="params">( <span class="keyword">const</span> account_name&amp; owner )</span></span>;</span><br></pre></td></tr></table></figure><p>claimrewards 函数的作用是支付超级节点的奖励。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setpriv</span><span class="params">( account_name account, <span class="keyword">uint8_t</span> ispriv )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>开发者可以通过 cleos system 子命令来测试这些功能。</p><p>如果要加入一个测试网络成为出块人，步骤应该是这样：</p><ul><li>注册账号</li><li>启动节点同步区块</li><li>注册成为候选人</li><li>抵押代币获得资源和投票权重</li><li>投票给自己</li><li>当得票足够后，等待一个周期，就可以成为出块人了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dawn 4.0 发布后，基本上白皮书上提到的特性都得到了实现，特别是投票、资源抵押和内存买卖。&lt;/p&gt;
&lt;p&gt;EOS 的网络带宽和计算资源是通过抵押代币的方式获得，如果不需要了可以解除抵押收回原先的代币。&lt;/p&gt;
&lt;p&gt;投票的权重和抵押代币所获得的带宽和计算资源相关，抵押了越多，投票的权重越大。同时投票的权重会随着时间的推移减少，这个设定鼓励用户持续更新自己的投票。&lt;/p&gt;
&lt;p&gt;而存储资源则是通过购买来得到，但是并不会消耗，当不再需要存储资源的时候可以出售。但是存储资源相对于 EOS 代币的价格会随着市场对于存储资源的需求而变动。&lt;/p&gt;
&lt;p&gt;而这些功能都是在 eosio.system 这个智能合约中实现。&lt;/p&gt;
&lt;p&gt;本文试图通过分析 eosio.system 中所有的功能函数来解读 eos 系统功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>EOSIO Dawn 3.0 智能合约</title>
    <link href="http://yoursite.com/2018/04/09/2018-4-9-EOSIO-Smart-Contract/"/>
    <id>http://yoursite.com/2018/04/09/2018-4-9-EOSIO-Smart-Contract/</id>
    <published>2018-04-09T05:07:00.000Z</published>
    <updated>2019-11-21T04:56:32.159Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#eosio-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e4%bb%8b%e7%bb%8d">EOSIO 智能合约介绍</a><ul><li><a href="#%e5%bf%85%e9%a1%bb%e7%9a%84%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86">必须的背景知识</a></li><li><a href="#eosio-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">EOSIO 智能合约基础知识</a></li></ul></li><li><a href="#%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e6%96%87%e4%bb%b6">智能合约文件</a><ul><li><a href="#hpp">hpp</a></li><li><a href="#cpp">cpp</a></li><li><a href="#wast">wast</a></li><li><a href="#abi">abi</a></li></ul></li><li><a href="#%e8%b0%83%e8%af%95%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6">调试智能合约</a><ul><li><a href="#%e6%96%b9%e6%b3%95">方法</a></li><li><a href="#%e6%89%93%e5%8d%b0">打印</a></li><li><a href="#%e4%be%8b%e5%ad%90">例子</a></li></ul></li></ul><!-- /TOC --><a id="more"></a><h2 id="EOSIO-智能合约介绍"><a href="#EOSIO-智能合约介绍" class="headerlink" title="EOSIO 智能合约介绍"></a>EOSIO 智能合约介绍</h2><h3 id="必须的背景知识"><a href="#必须的背景知识" class="headerlink" title="必须的背景知识"></a>必须的背景知识</h3><p><strong>C / C++ 经验</strong></p><p>基于 EOSIO 的区块链使用 <a href="http://webassembly.org/" target="_blank" rel="noopener">WebAssembly</a> (WASM) 执行用户生成的应用程序和代码。WASM 是一项新兴的网络标准，得到了谷歌，微软，苹果等公司的广泛支持。目前，用于构建编译为 WASM 的应用程序的最成熟工具链是使用 C/C++ 编译器的 <a href="https://clang.llvm.org/" target="_blank" rel="noopener">clang/llvm</a>。</p><p>其他第三方开发的工具链包括：Rust，Python 和 Solidity。虽然这些其他语言看起来可能更简单，但它们的性能可能会影响你可以构建的应用程序的规模。我们预计 C++ 将成为开发高性能和安全智能合约的最佳语言，并计划在可预见的将来使用 C++。</p><p><strong>Linux / Mac OS 经验</strong></p><p>EOSIO 软件支持以下环境:</p><ul><li>Amazon 2017.09 and higher</li><li>Centos 7</li><li>Fedora 25 and higher (Fedora 27 recommended)</li><li>Mint 18</li><li>Ubuntu 16.04 (Ubuntu 16.10 recommended)</li><li>MacOS Darwin 10.12 and higher (MacOS 10.13.x recommended)</li></ul><p><strong>命令行知识</strong></p><p>与 EOSIO 一起提供的各种工具，要求你具有基本的命令行知识才能与之交互。</p><h3 id="EOSIO-智能合约基础知识"><a href="#EOSIO-智能合约基础知识" class="headerlink" title="EOSIO 智能合约基础知识"></a>EOSIO 智能合约基础知识</h3><p><strong>交互模型</strong></p><p>EOSIO 智能合约以动作（actions）和共享内存数据库访问的形式彼此交互，<br>例如，合约可以读取其他合约数据库的状态，只要它包含在具有异步事务的读取范围内即可。<br>异步通信可能会导致资源限制算法会处理的垃圾邮件（spam）。<br>在合约中可以定义两种通信模式：</p><ul><li><p><strong>内联</strong>。内联保证与当前交易一起执行或展开; 无论成功或失败，都不会通知任何通知。内联与原有交易拥有相同的作用范围和权限。</p></li><li><p><strong>延期</strong>。延期交互将由出块人酌情决定如何执行; 可以传递交互结果或者可以简单地超时。延期交互可以有不同的作用范围，并带有发送它们的合约指定的权限。</p></li></ul><p><strong>动作 vs 交易</strong></p><p>一个动作表示单个操作，而一个交易是一个或多个动作的集合。合约和账户以动作的形式进行交流。动作可以单独发送，也可以组合的形式发送，如果它们打算作为一个整体来执行。</p><p><em>1 个动作的交易</em>.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"expiration"</span>: <span class="string">"2018-04-01T15:20:44"</span>,</span><br><span class="line">  <span class="attr">"region"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"ref_block_num"</span>: <span class="number">42580</span>,</span><br><span class="line">  <span class="attr">"ref_block_prefix"</span>: <span class="number">3987474256</span>,</span><br><span class="line">  <span class="attr">"net_usage_words"</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">"kcpu_usage"</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">"delay_sec"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"context_free_actions"</span>: [],</span><br><span class="line">  <span class="attr">"actions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"account"</span>: <span class="string">"eosio.token"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"issue"</span>,</span><br><span class="line">      <span class="attr">"authorization"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"actor"</span>: <span class="string">"eosio"</span>,</span><br><span class="line">          <span class="attr">"permission"</span>: <span class="string">"active"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"00000000007015d640420f000000000004454f5300000000046d656d6f"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"signatures"</span>: [<span class="string">""</span>],</span><br><span class="line">  <span class="attr">"context_free_data"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>多动作交易</em>, 这些动作会同时成功或失败.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"expiration"</span>: <span class="string">"..."</span>,</span><br><span class="line">  <span class="attr">"region"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"ref_block_num"</span>: ...,</span><br><span class="line">  <span class="attr">"ref_block_prefix"</span>: ...,</span><br><span class="line">  <span class="attr">"net_usage_words"</span>: ..,</span><br><span class="line">  <span class="attr">"kcpu_usage"</span>: ..,</span><br><span class="line">  <span class="attr">"delay_sec"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"context_free_actions"</span>: [],</span><br><span class="line">  <span class="attr">"actions"</span>: [&#123;</span><br><span class="line">      <span class="attr">"account"</span>: <span class="string">"..."</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"..."</span>,</span><br><span class="line">      <span class="attr">"authorization"</span>: [&#123;</span><br><span class="line">          <span class="attr">"actor"</span>: <span class="string">"..."</span>,</span><br><span class="line">          <span class="attr">"permission"</span>: <span class="string">"..."</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"account"</span>: <span class="string">"..."</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"..."</span>,</span><br><span class="line">      <span class="attr">"authorization"</span>: [&#123;</span><br><span class="line">          <span class="attr">"actor"</span>: <span class="string">"..."</span>,</span><br><span class="line">          <span class="attr">"permission"</span>: <span class="string">"..."</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"data"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"signatures"</span>: [</span><br><span class="line">    <span class="string">""</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"context_free_data"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动作名称限制</strong></p><p>动作类型实际上是 <strong>base32 编码的 64 位整数</strong> 。这意味着对于前 12 个字符它们仅限于字符 a-z，1-5 和 ‘.’ 。如果有第 13 个字符，则它仅限于前 16 个字符（’.’和 a-p）。</p><p><strong>交易确认</strong></p><p>接收交易哈希并不意味着交易已被确认，它只意味着节点认为没有错误并接受了它，这也意味着其他出块人很可能会接受它。</p><p>通过确认，你应该在交易历史中看到包含确认交易所属区块的交易。</p><h2 id="智能合约文件"><a href="#智能合约文件" class="headerlink" title="智能合约文件"></a>智能合约文件</h2><p>为了简单起见 ，我们创建了一个名为 <strong><a href="https://github.com/EOSIO/eos/wiki/Programs-&-Tools#eosiocpp" target="_blank" rel="noopener">eosiocpp</a></strong> 的工具，可以用来启动一个新的合约。eosiocpp 也将为你创建 3 个智能合约文件，并提供基本框架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eosiocpp -n $&#123;contract&#125;</span><br></pre></td></tr></table></figure><p>上面的命令将新建一个空项目，项目目录下有 3 个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;contract&#125;.abi $&#123;contract&#125;.hpp $&#123;contract&#125;.cpp</span><br></pre></td></tr></table></figure><h3 id="hpp"><a href="#hpp" class="headerlink" title="hpp"></a>hpp</h3><p><code>${contract}.hpp</code> 是被 <code>.cpp</code> 引用的，包含变量，常量和函数定义的头文件。</p><h3 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h3><p><code>${contract}.cpp</code> 文件是包含智能合约功能函数的源文件。</p><p>如果你使用 <code>eosiocpp</code> 工具生成 <code>.cpp</code> 文件，生成的 .cpp 文件与下面的相似:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;$&#123;contract&#125;.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The init() and apply() methods must have C calling convention so that the blockchain can lookup and</span></span><br><span class="line"><span class="comment"> *  call these methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  This method is called once when the contract is published or updated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">       eosio::print( <span class="string">"Init World!\n"</span> ); <span class="comment">// Replace with actual code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The apply method implements the dispatch of actions to this contract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">( <span class="keyword">uint64_t</span> code, <span class="keyword">uint64_t</span> action )</span> </span>&#123;</span><br><span class="line">       eosio::print( <span class="string">"Hello World: "</span>, eosio::name(code), <span class="string">"-&gt;"</span>, eosio::name(action), <span class="string">"\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// extern "C"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，你可以看到有两个函数， <code>init</code> 和 <code>apply</code>。<br>他们所做的只是记录动作，不做其他检查。只要出块人允许，任何人都可以随时提供任何操作。在没有任何所需的签名的情况下，合约将按照消耗的带宽收费。</p><p><strong>init</strong></p><p><code>init</code> 函数只会在初始部署时执行一次。用来初始化智能合约的变量，例如，代币合约的代币发行量。</p><p><strong>apply</strong></p><p><code>apply</code> 是动作处理器，它监听所有传入的动作并根据函数内的逻辑作出反应。该 apply 函数需要两个输入参数，<code>code</code> 和 <code>action</code>。</p><p><strong>代码过滤器</strong></p><p>为了应对特定的动作，<code>apply</code> 函数按以下方式编写。你也可以通过省略代码过滤器来编写对通用动作的响应。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code == N($&#123;contract_name&#125;) &#123;</span><br><span class="line">    <span class="comment">// your handler to respond to particular action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以在代码块中定义对各个操作的响应。</p><p><strong>动作过滤器</strong></p><p>为了响应某个特定动作，<code>apply</code> 函数按照以下方式编写。这通常与代码过滤器结合使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (action == N($&#123;action_name&#125;) &#123;</span><br><span class="line">    <span class="comment">//your handler to respond to a particular action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="wast"><a href="#wast" class="headerlink" title="wast"></a>wast</h3><p>任何要部署到 EOSIO 区块链的程序都必须编译为 WASM 格式。这是区块链接受的唯一格式。</p><p>准备好 CPP 文件后，可以使用 <code>eosiocpp</code> 工具将其编译为 WASM（.wast）的文本版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eosiocpp -o $&#123;contract&#125;.wast $&#123;contract&#125;.cpp</span><br></pre></td></tr></table></figure><h3 id="abi"><a href="#abi" class="headerlink" title="abi"></a>abi</h3><p>应用程序二进制接口（ABI）是一种基于 JSON 的描述，介绍如何将用户动作在 JSON 和二进制表达之间转换。ABI 还介绍了如何将数据库状态转换为 JSON 或从 JSON 转换数据库状态。通过 ABI 描述了智能合约，开发人员和用户就可以通过 JSON 无缝地与你的合约进行交互。</p><p>ABI 文件可以通过使用 <code>eosiocpp</code> 工具从 <code>.hpp</code> 文件生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eosiocpp -g $&#123;contract&#125;.abi $&#123;contract&#125;.hpp</span><br></pre></td></tr></table></figure><p>以下是框架合约 ABI 的示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"types"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"new_type_name"</span>: <span class="string">"account_name"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"name"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"structs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"transfer"</span>,</span><br><span class="line">      <span class="attr">"base"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"from"</span>: <span class="string">"account_name"</span>,</span><br><span class="line">        <span class="attr">"to"</span>: <span class="string">"account_name"</span>,</span><br><span class="line">        <span class="attr">"quantity"</span>: <span class="string">"uint64"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"account"</span>,</span><br><span class="line">      <span class="attr">"base"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"account"</span>: <span class="string">"name"</span>,</span><br><span class="line">        <span class="attr">"balance"</span>: <span class="string">"uint64"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"actions"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"action"</span>: <span class="string">"transfer"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"transfer"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"tables"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"table"</span>: <span class="string">"account"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"account"</span>,</span><br><span class="line">      <span class="attr">"index_type"</span>: <span class="string">"i64"</span>,</span><br><span class="line">      <span class="attr">"key_names"</span>: [<span class="string">"account"</span>],</span><br><span class="line">      <span class="attr">"key_types"</span>: [<span class="string">"name"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会注意到这个 ABI 定义了一个 <code>transfer</code> 类型的动作 <code>transfer</code> 。这告诉 EOSIO，当 <code>${account}-&gt;transfer</code> 被看到时，交易的负载（payload）类型是 <code>transfer</code> 。动作类型 <code>transfer</code> 在 <code>structs</code> 数组中被定义，<code>structs</code> 数组对象中，<code>name</code> 属性的值为 <code>transfer</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  "structs": [&#123;</span><br><span class="line">      "name": "transfer",</span><br><span class="line">      "base": "",</span><br><span class="line">      "fields": &#123;</span><br><span class="line">        "from": "account_name",</span><br><span class="line">        "to": "account_name",</span><br><span class="line">        "quantity": "uint64"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>该 ABI 有好几个字段，包括 <code>from</code>, <code>to</code> 和 <code>quantity</code> 。<br>这些字段有相应的类型 <code>account_name</code>, 和 <code>uint64</code> 。<br><code>account_name</code> 是一个内置的类型使用 <code>uint64</code> 来表示 base32 字符串。<br>要详细了解可用的内置类型，请点击<a href="https://github.com/EOSIO/eos/blob/master/libraries/chain/contracts/abi_serializer.cpp" target="_blank" rel="noopener">此处</a>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"types"</span>: [&#123;</span><br><span class="line">      <span class="attr">"new_type_name"</span>: <span class="string">"account_name"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"name"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在上面的 <code>types</code> 数组中，我们为已存在类型定义了一个别名列表。在这里，我们定义 <code>name</code> 为 <code>account_name</code> 的一个别名。</p><h2 id="调试智能合约"><a href="#调试智能合约" class="headerlink" title="调试智能合约"></a>调试智能合约</h2><p>为了能够调试你的智能合约，你需要设置本地 nodeos 节点。这个本地 nodeos 节点可以作为独立的私人测试网或作为公共测试网（或官方测试网）的扩展来运行。</p><p>当你首次创建智能合约时，建议先在私人测试网上测试并调试你的智能合约，因为你完全控制了整个区块链。这使你可以拥有无 ​​ 限量你所需要的 eos，你可以随时重置区块链状态。当准备发布到生产环境时，可以通过将本地节点连接到公共测试网（或官方测试网）来在公共测试网（或官方测试网）上进行调试，以便你可以在本地节点中看到测试网的日志。</p><p>下面的教程，将在私人测试网上进行调试。</p><p>如果你尚未设置自己的本地节点，请按照 <a href="https://github.com/eosfansio/eos-tutorials/blob/master/EOS3.0-%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.md" target="_blank" rel="noopener">启动指南</a> 进行操作。默认情况下，除非你按照 <a href="Testnet%3A%20Public">Testnet 指南</a> 中所述修改 config.ini 文件以便与公共 testnet（或官方 testnet）节点连接，否则你的本地节点将仅运行在私有测试网络中。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>用于调试智能合约的主要方法是 <strong>穴居人调试</strong>（<strong>Caveman Debugging</strong>），我们利用打印功能来检查变量的值并检查合约的流程。在智能合约中打印可以通过打印 API (<a href="https://github.com/EOSIO/eos/blob/master/contracts/eoslib/print.h" target="_blank" rel="noopener">C</a> 和 <a href="https://github.com/EOSIO/eos/blob/master/contracts/eoslib/print.hpp" target="_blank" rel="noopener">C++</a>) 完成。C++ API 是 C API 的封装器，因此大多数情况下我们只会使用 C++ API。</p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>打印 C API 支持你可以打印的以下数据类型：</p><ul><li>prints - 一个带 null 终止符的字符数组（字符串）</li><li>prints_l - 给定大小的任何字符数组（字符串）</li><li>printi - 64 位无符号整数</li><li>printi128 - 128 位无符号整数</li><li>printd - 编码为 64 位无符号整数的浮点类型</li><li>printn - 编码为 64 位无符号整数的 base32 字符串</li><li>printhex - 给出二进制数据及其大小的十六进制</li></ul><p>打印 C++ API 通过重写 print() 函数来封装一些上述 C API，因此用户不需要确定他需要使用哪种特定的打印功能。</p><p>打印 C++ API 支持：</p><ul><li>一个带 null 终止符的字符数组（字符串）</li><li>整数（128 位无符号，64 位无符号，32 位无符号，有符号，无符号）</li><li>编码为 64 位无符号整数的 base32 字符串</li><li>具有 print() 方法的结构体</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们来写一个新的合约作为调试的例子</p><ul><li>debug.hpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eoslib/eos.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;eoslib/db.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> debug &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">        account_name from;</span><br><span class="line">        account_name to;</span><br><span class="line">        <span class="keyword">uint64_t</span> amount;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            eosio::print(<span class="string">"Foo from "</span>, eosio::name(from), <span class="string">" to "</span>,eosio::name(to), <span class="string">" with amount "</span>, amount, <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>debug.cpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;debug.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">( <span class="keyword">uint64_t</span> code, <span class="keyword">uint64_t</span> action )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code == N(debug)) &#123;</span><br><span class="line">            eosio::print(<span class="string">"Code is debug\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> (action == N(foo)) &#123;</span><br><span class="line">                 eosio::print(<span class="string">"Action is foo\n"</span>);</span><br><span class="line">                debug::foo f = eosio::current_message&lt;debug::foo&gt;();</span><br><span class="line">                <span class="keyword">if</span> (f.amount &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    eosio::print(<span class="string">"Amount is larger or equal than 100\n"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    eosio::print(<span class="string">"Amount is smaller than 100\n"</span>);</span><br><span class="line">                    eosio::print(<span class="string">"Increase amount by 10\n"</span>);</span><br><span class="line">                    f.amount += <span class="number">10</span>;</span><br><span class="line">                    eosio::print(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// extern "C"</span></span><br></pre></td></tr></table></figure><ul><li>debug.hpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"structs"</span>: [&#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">      <span class="string">"base"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"fields"</span>: &#123;</span><br><span class="line">        <span class="string">"from"</span>: <span class="string">"account_name"</span>,</span><br><span class="line">        <span class="string">"to"</span>: <span class="string">"account_name"</span>,</span><br><span class="line">        <span class="string">"amount"</span>: <span class="string">"uint64"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"actions"</span>: [&#123;</span><br><span class="line">      <span class="string">"action_name"</span>: <span class="string">"foo"</span>,</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"foo"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们部署它并发送一条消息给它。假设你已经创建 <code>debug</code> 帐户并在将私钥导入你的钱包中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ eosiocpp -o debug.wast debug.cpp</span><br><span class="line">$ cleos <span class="built_in">set</span> contract debug debug.wast debug.abi</span><br><span class="line">$ cleos push message debug foo <span class="string">'&#123;"from":"inita", "to":"initb", "amount":10&#125;'</span> --scope debug</span><br></pre></td></tr></table></figure><p>当你检查你的本地 <code>nodeos</code> 节点日志时，你将在发送上述消息后看到以下行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Code is debug</span><br><span class="line">Action is foo</span><br><span class="line">Amount is smaller than 100</span><br><span class="line">Increase amount by 10</span><br><span class="line">Foo from inita to initb with amount 20</span><br></pre></td></tr></table></figure><p>这里，你可以确认你的消息正在进入正确的控制流程并且金额已正确更新。你可能会看到上述消息至少 2 次，这很正常，<br>因为每个交易在验证、块生成和块应用阶段都会被执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#eosio-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e4%bb%8b%e7%bb%8d&quot;&gt;EOSIO 智能合约介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e5%bf%85%e9%a1%bb%e7%9a%84%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86&quot;&gt;必须的背景知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#eosio-%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86&quot;&gt;EOSIO 智能合约基础知识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e6%96%87%e4%bb%b6&quot;&gt;智能合约文件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#hpp&quot;&gt;hpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cpp&quot;&gt;cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wast&quot;&gt;wast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#abi&quot;&gt;abi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e8%b0%83%e8%af%95%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6&quot;&gt;调试智能合约&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%96%b9%e6%b3%95&quot;&gt;方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%89%93%e5%8d%b0&quot;&gt;打印&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e4%be%8b%e5%ad%90&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>EOS 相关汇总</title>
    <link href="http://yoursite.com/2018/02/07/2018-02-07-eos-document/"/>
    <id>http://yoursite.com/2018/02/07/2018-02-07-eos-document/</id>
    <published>2018-02-07T09:55:00.000Z</published>
    <updated>2019-11-09T00:05:03.478Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="http://blog.eosdata.io/index.php/links/" target="_blank" rel="noopener">http://blog.eosdata.io/index.php/links/</a>                                                                            //     eos开发者的hao123</li><li><a href="https://github.com/EOSIO/Documentation" target="_blank" rel="noopener">https://github.com/EOSIO/Documentation</a>                                                                    //  Github上所有文档</li><li><a href="https://www.jianshu.com/p/bc489db794ce" target="_blank" rel="noopener">https://www.jianshu.com/p/bc489db794ce</a>                                                                    //  eos中文白皮书</li><li><a href="https://github.com/EOSIO/Documentation/blob/master/zh-CN/Roadmap.md" target="_blank" rel="noopener">https://github.com/EOSIO/Documentation/blob/master/zh-CN/Roadmap.md</a>           //    eos开发路线图</li><li><a href="https://www.youtube.com/watch?v=DWxZULsFcF0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=DWxZULsFcF0</a>                                                    //    官方推介会youtube视频(40min)</li><li><a href="https://www.jianshu.com/u/2c20674f10bb" target="_blank" rel="noopener">https://www.jianshu.com/u/2c20674f10bb</a>                                                                    //   《eos入门到精通》技术解析</li><li><a href="http://vdisk.weibo.com/s/yUM-q4I09jbOT" target="_blank" rel="noopener">http://vdisk.weibo.com/s/yUM-q4I09jbOT</a>                                                                    //    Dpos共识白皮书</li><li><a href="https://twitter.com/search?src=typd&amp;q=Dan%20Larimer" target="_blank" rel="noopener">https://twitter.com/search?src=typd&amp;q=Dan%20Larimer</a>                                            //    Dan Larimer的Twitter</li><li><a href="https://www.youtube.com/watch?v=6cDTeIycI6c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=6cDTeIycI6c</a>                                                        //  Dan Larimer采访</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.eosdata.io/index.php/links/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.eosdata.io/index.php/links/&lt;/a&gt;       
      
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="EOS" scheme="http://yoursite.com/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>使用 NodeJS 调用 API 接口 进行转账和 Bitshares 内盘交易</title>
    <link href="http://yoursite.com/2018/01/25/2018-01-25-bitsharesjs-sample/"/>
    <id>http://yoursite.com/2018/01/25/2018-01-25-bitsharesjs-sample/</id>
    <published>2018-01-25T01:55:00.000Z</published>
    <updated>2019-11-21T04:56:41.654Z</updated>
    
    <content type="html"><![CDATA[<p>使用官方的 bitsharesjs 库进行开发，参考了官方的转账例子，补充了下单的部分，更多的使用细节需要自己研究代码。</p><a id="more"></a><p>这里附上转账和下单的示例函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* import &#123;Apis&#125; from "bitsharesjs-ws";</span></span><br><span class="line"><span class="comment">import &#123;ChainStore, FetchChain, PrivateKey, TransactionHelper, Aes, TransactionBuilder&#125; from "bitsharesjs"; */</span></span><br><span class="line"><span class="keyword">const</span> Apis = <span class="built_in">require</span>(<span class="string">"bitsharesjs-ws"</span>).Apis;</span><br><span class="line"><span class="keyword">const</span> ChainStore = <span class="built_in">require</span>(<span class="string">"bitsharesjs"</span>).ChainStore;</span><br><span class="line"><span class="keyword">const</span> FetchChain = <span class="built_in">require</span>(<span class="string">"bitsharesjs"</span>).FetchChain;</span><br><span class="line"><span class="keyword">const</span> PrivateKey = <span class="built_in">require</span>(<span class="string">"bitsharesjs"</span>).PrivateKey;</span><br><span class="line"><span class="keyword">const</span> TransactionHelper = <span class="built_in">require</span>(<span class="string">"bitsharesjs"</span>).TransactionHelper;</span><br><span class="line"><span class="keyword">const</span> Aes = <span class="built_in">require</span>(<span class="string">"bitsharesjs"</span>).Aes;</span><br><span class="line"><span class="keyword">const</span> TransactionBuilder = <span class="built_in">require</span>(<span class="string">"bitsharesjs"</span>).TransactionBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BTS_PRECISION = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> CNY_PRECISION = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss_url = <span class="string">"wss://bitshares-api.wancloud.io/ws"</span>;</span><br><span class="line"><span class="keyword">var</span> privKey = <span class="string">"privKey"</span>; <span class="comment">//change to your privKey</span></span><br><span class="line"><span class="keyword">let</span> pKey = PrivateKey.fromWif(privKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transfer = <span class="function"><span class="keyword">function</span>(<span class="params">fromAccount, toAccount, sendAmount, memo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    Apis.instance(wss_url, <span class="literal">true</span>).init_promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"connected to:"</span>, res[<span class="number">0</span>].network_name, <span class="string">"network"</span>);</span><br><span class="line"></span><br><span class="line">      ChainStore.init().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> memoSender = fromAccount;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Promise</span>.all([</span><br><span class="line">          FetchChain(<span class="string">"getAccount"</span>, fromAccount),</span><br><span class="line">          FetchChain(<span class="string">"getAccount"</span>, toAccount),</span><br><span class="line">          FetchChain(<span class="string">"getAccount"</span>, memoSender),</span><br><span class="line">          FetchChain(<span class="string">"getAsset"</span>, sendAmount.asset),</span><br><span class="line">          FetchChain(<span class="string">"getAsset"</span>, sendAmount.asset)</span><br><span class="line">        ]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// console.log("got data:", res);</span></span><br><span class="line">          <span class="keyword">let</span> [fromAccount, toAccount, memoSender, sendAsset, feeAsset] = res;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Memos are optional, but if you have one you need to encrypt it here</span></span><br><span class="line">          <span class="keyword">let</span> memoFromKey = memoSender.getIn([<span class="string">"options"</span>, <span class="string">"memo_key"</span>]);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"memo pub key:"</span>, memoFromKey);</span><br><span class="line">          <span class="keyword">let</span> memoToKey = toAccount.getIn([<span class="string">"options"</span>, <span class="string">"memo_key"</span>]);</span><br><span class="line">          <span class="keyword">let</span> nonce = TransactionHelper.unique_nonce_uint64();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> memo_object = &#123;</span><br><span class="line">            <span class="keyword">from</span>: memoFromKey,</span><br><span class="line">            to: memoToKey,</span><br><span class="line">            nonce,</span><br><span class="line">            message: Aes.encrypt_with_checksum(pKey, memoToKey, nonce, memo)</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> tr = <span class="keyword">new</span> TransactionBuilder();</span><br><span class="line"></span><br><span class="line">          tr.add_type_operation(<span class="string">"transfer"</span>, &#123;</span><br><span class="line">            fee: &#123;</span><br><span class="line">              amount: <span class="number">0</span>,</span><br><span class="line">              asset_id: feeAsset.get(<span class="string">"id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">from</span>: fromAccount.get(<span class="string">"id"</span>),</span><br><span class="line">            to: toAccount.get(<span class="string">"id"</span>),</span><br><span class="line">            amount: &#123;</span><br><span class="line">              amount: sendAmount.amount,</span><br><span class="line">              asset_id: sendAsset.get(<span class="string">"id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            memo: memo_object</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          tr.set_required_fees().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            tr.add_signer(pKey, pKey.toPublicKey().toPublicKeyString());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"serialized transaction:"</span>, tr.serialize());</span><br><span class="line">            tr.broadcast(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">"transaction done"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transferBTS = <span class="function"><span class="keyword">function</span>(<span class="params">fromAccount, toAccount, amount, memo</span>) </span>&#123;</span><br><span class="line">  transfer(</span><br><span class="line">    fromAccount,</span><br><span class="line">    toAccount,</span><br><span class="line">    &#123; <span class="attr">amount</span>: amount * BTS_PRECISION, <span class="attr">asset</span>: <span class="string">"BTS"</span> &#125;,</span><br><span class="line">    memo</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> create_order = <span class="function"><span class="keyword">function</span>(<span class="params">orderAccount, sellAmount, buyAmount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    Apis.instance(wss_url, <span class="literal">true</span>).init_promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"connected to:"</span>, res[<span class="number">0</span>].network_name, <span class="string">"network"</span>);</span><br><span class="line"></span><br><span class="line">      ChainStore.init().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.all([</span><br><span class="line">          FetchChain(<span class="string">"getAccount"</span>, orderAccount),</span><br><span class="line">          FetchChain(<span class="string">"getAsset"</span>, sellAmount.asset),</span><br><span class="line">          FetchChain(<span class="string">"getAsset"</span>, buyAmount.asset)</span><br><span class="line">        ]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// console.log("got data:", res);</span></span><br><span class="line">          <span class="keyword">let</span> orderAccount = res[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">let</span> sellAsset = res[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">let</span> feeAsset = sellAsset;</span><br><span class="line">          <span class="keyword">let</span> buyAsset = res[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> tr = <span class="keyword">new</span> TransactionBuilder();</span><br><span class="line"></span><br><span class="line">          tr.add_type_operation(<span class="string">"limit_order_create"</span>, &#123;</span><br><span class="line">            fee: &#123;</span><br><span class="line">              amount: <span class="number">0</span>,</span><br><span class="line">              asset_id: feeAsset.get(<span class="string">"id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            seller: orderAccount.get(<span class="string">"id"</span>),</span><br><span class="line">            amount_to_sell: &#123;</span><br><span class="line">              amount: sellAmount.amount,</span><br><span class="line">              asset_id: sellAsset.get(<span class="string">"id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            min_to_receive: &#123;</span><br><span class="line">              amount: buyAmount.amount,</span><br><span class="line">              asset_id: buyAsset.get(<span class="string">"id"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            expiration: <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() / <span class="number">1000</span>) + <span class="number">20</span>,</span><br><span class="line">            fill_or_kill: <span class="literal">false</span></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          tr.set_required_fees().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            tr.add_signer(pKey, pKey.toPublicKey().toPublicKeyString());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"serialized transaction:"</span>, tr.serialize());</span><br><span class="line">            tr.broadcast(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">"transaction done"</span>);</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">transferBTS(<span class="string">"imba"</span>, <span class="string">"qiushaoxi"</span>, <span class="number">0.05</span>, <span class="string">"test nodejs"</span>);</span><br><span class="line">create_order(</span><br><span class="line">  <span class="string">"imba"</span>,</span><br><span class="line">  &#123; <span class="attr">amount</span>: <span class="number">0.5</span> * BTS_PRECISION, <span class="attr">asset</span>: <span class="string">"BTS"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">amount</span>: <span class="number">5</span> * CNY_PRECISION, <span class="attr">asset</span>: <span class="string">"CNY"</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用官方的 bitsharesjs 库进行开发，参考了官方的转账例子，补充了下单的部分，更多的使用细节需要自己研究代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BitShares" scheme="http://yoursite.com/tags/BitShares/"/>
    
  </entry>
  
  <entry>
    <title>Bitshares 私链部署witness节点</title>
    <link href="http://yoursite.com/2017/12/20/2017-12-20-bitshares-witness/"/>
    <id>http://yoursite.com/2017/12/20/2017-12-20-bitshares-witness/</id>
    <published>2017-12-20T01:55:00.000Z</published>
    <updated>2019-11-21T04:56:51.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单节点私链搭建请参考 剑有偏峰 的文章：</p><p><a href="http://www.jianshu.com/p/b54782cd1926" target="_blank" rel="noopener">比特股环境搭建</a></p><p><a href="http://www.jianshu.com/p/5be0344e30cd" target="_blank" rel="noopener">编译比特股网页钱包</a></p><p><a href="http://www.jianshu.com/p/a89b3835d4e8" target="_blank" rel="noopener">搭建比特股的水龙头注册服务</a></p><h1 id="多节点部署"><a href="#多节点部署" class="headerlink" title="多节点部署"></a>多节点部署</h1><p>通过之前的文章，部署了单节点的 Bitshares 区块链，接下去模拟真实场景，应该是有很多区块链节点才能实现去中心化高可用的架构。</p><a id="more"></a><p>在另一台机器上同样编译 Bitshares-core ，将原来的 genesis.json 复制到本机的 bitshares-core/programs/witness_node 目录下，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./witness_node   -d test_net --seed-nodes &quot;[]&quot; --genesis-json &quot;genesis.json&quot;</span><br></pre></td></tr></table></figure><p>会初始化目录 test_net<br>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl-c</span><br></pre></td></tr></table></figure><p>退出程序，编辑 test_net/config.ini，修改如下几项配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p2p-endpoint = 0.0.0.0:9090</span><br><span class="line">seed-nodes = [&quot;192.168.23.248:9090&quot;]</span><br><span class="line">rpc-endpoint = 0.0.0.0:8090</span><br><span class="line">enable-stale-production = true</span><br></pre></td></tr></table></figure><p>其中 seed-nodes 填写之前启动的区块链节点的 ip 和 p2p-endpoint 端口</p><p>再次启动 witness 程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./witness_node   -d test_net</span><br></pre></td></tr></table></figure><p>这样就成功部署了另一个区块链节点，但是由于没有 witness 权限，所以不会出块，只会同步区块信息。</p><p>从 github 下载下来的代码启动私链，默认的 witness 是 init0 ～ inti10。</p><h1 id="成为-witness"><a href="#成为-witness" class="headerlink" title="成为 witness"></a>成为 witness</h1><p>这里默认读者已经会使用 cli_wallet .</p><p>启动 cli_wallet ，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suggest_brain_key</span><br></pre></td></tr></table></figure><p>获得新账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;brain_priv_key&quot;: &quot;LYSSA JUBILEE GIDDIFY KEMPITE INULASE SOBBER GROVEL ENCLAVE T SAHME MYXA GLIDE OVERALL SYNC GROWLER THRILL&quot;,</span><br><span class="line">  &quot;wif_priv_key&quot;: &quot;5Jiie6zMJWAJ6P8QmivSVjfbPyWa9uKNtwtFXQC3TBoGZDnKXwN&quot;,</span><br><span class="line">  &quot;pub_key&quot;: &quot;BTS7Zpu3gZmVAGAXgGbD4CzJBwP9uFWtwN5V83TnJQsF9eZ6CnSMx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果之前没有 import nathan 用户，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import_key nathan 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3</span><br></pre></td></tr></table></figure><p>nathan 如果看过之前帖子应该知道是什么。</p><p>通过生成的 pub_key 注册用户 joshua（任意名称）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register_account joshua &quot;BTS7Zpu3gZmVAGAXgGbD4CzJBwP9uFWtwN5V83TnJQsF9eZ6CnSMx&quot; &quot;BTS7Zpu3gZmVAGAXgGbD4CzJBwP9uFWtwN5V83TnJQsF9eZ6CnSMx&quot; nathan nathan 50 true</span><br></pre></td></tr></table></figure><p>从 nathan 账户转一部分 BTS 到新建的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfer nathan joshua 2000000000 BTS &quot;here is some cash&quot; true</span><br></pre></td></tr></table></figure><p>导入用户的私钥到 cli 钱包，私钥是刚才生成内容的 wif_priv_key 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import_key joshua 5Jiie6zMJWAJ6P8QmivSVjfbPyWa9uKNtwtFXQC3TBoGZDnKXwN</span><br></pre></td></tr></table></figure><p>升级用户成为终身成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upgrade_account joshua true</span><br></pre></td></tr></table></figure><p>创建 witness 用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_witness joshua &quot;&quot; true</span><br></pre></td></tr></table></figure><p>为新建的 witness 用户投票，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vote_for_witness joshua joshua true true</span><br></pre></td></tr></table></figure><p>获取 witness 公私钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_witness joshua</span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;1.6.12&quot;,</span><br><span class="line">  &quot;witness_account&quot;: &quot;1.2.18&quot;,</span><br><span class="line">  &quot;last_aslot&quot;: 52765,</span><br><span class="line">  &quot;signing_key&quot;: &quot;BTS6UyKzfSim5anCFKZsWB8HPtBSwt8yUthiFCE6oaTXo9Qf6z85e&quot;,</span><br><span class="line">  &quot;pay_vb&quot;: &quot;1.13.9&quot;,</span><br><span class="line">  &quot;vote_id&quot;: &quot;1:22&quot;,</span><br><span class="line">  &quot;total_votes&quot;: &quot;898790081908868&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;&quot;,</span><br><span class="line">  &quot;total_missed&quot;: 13,</span><br><span class="line">  &quot;last_confirmed_block_num&quot;: 15402</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>witness 的公钥就是”signing_key”字段，记录下 witness_account ，后面配置有用，再执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump_private_keys</span><br></pre></td></tr></table></figure><p>获取目前钱包中存储的私钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[</span><br><span class="line">    &quot;BTS78CuY47Vds2nfw2t88ckjTaggPkw16tLhcmg4ReVx1WPr1zRL5&quot;,</span><br><span class="line">    &quot;5JDh3XmHK8CDaQSxQZHh5PUV3zwzG68uVcrTfmg9yQ9idNisYnE&quot;</span><br><span class="line">  ],[</span><br><span class="line">    &quot;BTS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;,</span><br><span class="line">    &quot;5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3&quot;</span><br><span class="line">  ],[</span><br><span class="line">    &quot;BTS7Zpu3gZmVAGAXgGbD4CzJBwP9uFWtwN5V83TnJQsF9eZ6CnSMx&quot;,</span><br><span class="line">    &quot;5Jiie6zMJWAJ6P8QmivSVjfbPyWa9uKNtwtFXQC3TBoGZDnKXwN&quot;</span><br><span class="line">  ],[</span><br><span class="line">    &quot;BTS6UyKzfSim5anCFKZsWB8HPtBSwt8yUthiFCE6oaTXo9Qf6z85e&quot;,</span><br><span class="line">    &quot;5JM1AsnRJDGDa8x7NR3GtNDhQzzNi6VEs9XmXyuDhLEnJDUwnS8&quot;</span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>根据”signing_key”获取对应的私钥，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;BTS6UyKzfSim5anCFKZsWB8HPtBSwt8yUthiFCE6oaTXo9Qf6z85e&quot;,&quot;5JM1AsnRJDGDa8x7NR3GtNDhQzzNi6VEs9XmXyuDhLEnJDUwnS8&quot;]</span><br></pre></td></tr></table></figure><p>记录好这个公私钥对，接下去修改 test_net/config.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># ID of witness controlled by this node (e.g. &quot;1.6.5&quot;, quotes are required, may specify multiple times)</span><br><span class="line">witness-id = &quot;1.6.2&quot;</span><br><span class="line">witness-id = &quot;1.6.3&quot;</span><br><span class="line">witness-id = &quot;1.6.12&quot;</span><br><span class="line"></span><br><span class="line"># Tuple of [PublicKey, WIF private key] (may specify multiple times)</span><br><span class="line">private-key = [&quot;BTS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;,&quot;5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3&quot;]</span><br><span class="line">private-key = [&quot;BTS6UyKzfSim5anCFKZsWB8HPtBSwt8yUthiFCE6oaTXo9Qf6z85e&quot;,&quot;5JM1AsnRJDGDa8x7NR3GtNDhQzzNi6VEs9XmXyuDhLEnJDUwnS8&quot;]</span><br></pre></td></tr></table></figure><p>增加新建的 witness-id 和对应的公私钥，重启 witness 重需</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./witness_node   -d test_net</span><br></pre></td></tr></table></figure><p><em>这一部分就完成了</em></p><p>不过因为默认的更新 witness 的时间比较长，24 小时，所以要等 24 小时才能看到 joshua 成为 witness，如果想快一点，需要重头开始做，在执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./witness_node --create-genesis-json &quot;genesis.json&quot;</span><br></pre></td></tr></table></figure><p>之后，编辑 genesis.json，修改下面这个参数为 600，这样 10 分钟就会更新 witness</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;maintenance_interval&quot;: 600,</span><br></pre></td></tr></table></figure><hr><p><img src="http://upload-images.jianshu.io/upload_images/7302525-95ffade6d5ccc8e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;单节点私链搭建请参考 剑有偏峰 的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/b54782cd1926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;比特股环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/5be0344e30cd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;编译比特股网页钱包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/a89b3835d4e8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搭建比特股的水龙头注册服务&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;多节点部署&quot;&gt;&lt;a href=&quot;#多节点部署&quot; class=&quot;headerlink&quot; title=&quot;多节点部署&quot;&gt;&lt;/a&gt;多节点部署&lt;/h1&gt;&lt;p&gt;通过之前的文章，部署了单节点的 Bitshares 区块链，接下去模拟真实场景，应该是有很多区块链节点才能实现去中心化高可用的架构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BitShares" scheme="http://yoursite.com/tags/BitShares/"/>
    
  </entry>
  
  <entry>
    <title>在 Swarm 集群环境部署 Fabric 区块链</title>
    <link href="http://yoursite.com/2017/12/07/2017-12-07-fabric-in-swarm/"/>
    <id>http://yoursite.com/2017/12/07/2017-12-07-fabric-in-swarm/</id>
    <published>2017-12-07T04:55:00.000Z</published>
    <updated>2019-11-21T04:56:55.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>fabric 部署本来就是一件麻烦的事情，如果还涉及到多机环境部署那就更加的麻烦了。<br>因为 fabric 推荐部署在 docker 环境中，那很自然地想到通过集群部署工具来部署 fabric。本文就通过例子来说明如何在 Swarm 集群中部署 fabric 区块链网络。</p><p>还有之前看到过张海宁的<a href="https://github.com/hainingzhang/articles/blob/master/fabric_multi_nodes/FabricMultiNodev2-3.pdf" target="_blank" rel="noopener">k8s 部署方案</a>，供大家参考。</p><p>文中所有 IP 地址,如 192.168.1.93，都需要根据你本地的情况输入。</p><p>本例子 github 地址：<a href="https://github.com/qiushaoxi/fabric-in-swarm.git" target="_blank" rel="noopener">fabric-in-swarm</a> , 欢迎 star.</p><a id="more"></a><h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><p><img src="/img/fabric-in-swarm/architect.png" alt="架构图"></p><p>docker swarm 会在各台机器之上 创建一个 overlay 虚拟网络，通过 swarm 启动的 container 可以跨主机互相访问。</p><p>docker service 是 swarm 编排的最小单位，可以配置运行的镜像、网络端口、环境变量等，一个 service 可以启动多个 container 进行负载均衡。不过因为区块链中每个节点都有不同的配置，本例子中每个 service 只跑一个 container。后续可以继续探讨启动多个 container 的场景。</p><p>docker stack 则是一组 service 的合集， 每个 stack 会默认创建一个 default 的 overlay 网络，其中还可以再配置其他网络。 stack 本意是技术栈，通过在 stack 中配置前后端、中间件等 service，可以实现一键部署整个技术栈。本例子的 stack 中，配置了 1 个 orderer、4 个 peer 和 1 个 cli 一共 6 个 service。后续可以根据需要加入 kafka、couchdb 等 service。</p><p>swarm 集群会对外暴露一个 IP，通过端口映射，可以访问到具体 service 的端口。</p><h2 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h2><h3 id="Swarm-集群搭建"><a href="#Swarm-集群搭建" class="headerlink" title="Swarm 集群搭建"></a>Swarm 集群搭建</h3><h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><p>如果还没有安装 docker ，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | sh</span><br></pre></td></tr></table></figure><h4 id="在-leader-创建-Swarm-集群"><a href="#在-leader-创建-Swarm-集群" class="headerlink" title="在 leader 创建 Swarm 集群"></a>在 leader 创建 Swarm 集群</h4><p>选择一台机器作为 leader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.1.93</span><br></pre></td></tr></table></figure><p>这里的 ip 是整个 swarm 集群对外的 ip，所有 swarm 集群里面的容器都通过这个 ip 对外提供服务。</p><p>执行返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join /</span><br><span class="line">    --token SWMTKN-1-16kit6dksvrqilgptjg5pvu0tvo5qfs8uczjq458lf9mul41hc-dzvgu0h3qngfgihz4fv0855bo /</span><br><span class="line">    192.168.1.93:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><h4 id="其他机器加入-Swarm-集群"><a href="#其他机器加入-Swarm-集群" class="headerlink" title="其他机器加入 Swarm 集群"></a>其他机器加入 Swarm 集群</h4><p>根据第一步返回的命令加入集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join /</span><br><span class="line">--token SWMTKN-1-16kit6dksvrqilgptjg5pvu0tvo5qfs8uczjq458lf9mul41hc-dzvgu0h3qngfgihz4fv0855bo /</span><br><span class="line">192.168.1.93:2377</span><br></pre></td></tr></table></figure><p>所有其他机器执行命令后，在 leader 执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure><p>如果能看到所有机器，说明操作成功，Swarm 集群搭建完毕。</p><h4 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h4><p>这里推荐一个开源的 docker 后台管理工具<a href="https://portainer.io/" target="_blank" rel="noopener">portainer</a>，也支持 Swarm 集群的管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--replicas=1 \</span><br><span class="line">--constraint &apos;node.role == manager&apos; \</span><br><span class="line">--mount type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>执行这个命令就可以在 Swarm 中启动，然后访问 Swarm_IP:9000 就可以进行管理后台，初次需要设置密码。</p><h3 id="NFS-服务器搭建"><a href="#NFS-服务器搭建" class="headerlink" title="NFS 服务器搭建"></a>NFS 服务器搭建</h3><p>因为集群容器需要读取一些文件，所以需要搭一个文件服务器。</p><h4 id="安装-nfs-kernel-server"><a href="#安装-nfs-kernel-server" class="headerlink" title="安装 nfs-kernel-server"></a>安装 nfs-kernel-server</h4><p>可以在任意台机器安装，本例子就在 swarm manager 的机器上安装的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-common</span><br><span class="line">apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/exports</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/nfs *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure><p>各段表达的意思如下，根据实际进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/nfs   ：共享的目录</span><br><span class="line">*       ：指定哪些用户可以访问</span><br><span class="line">            *  所有可以ping同该主机的用户</span><br><span class="line">            192.168.1.*  指定网段，在该网段中的用户可以挂载</span><br><span class="line">            192.168.1.12 只有该用户能挂载</span><br><span class="line">(ro,sync,no_root_squash)：  权限</span><br><span class="line">        ro : 只读</span><br><span class="line">        rw : 读写</span><br><span class="line">        sync :  同步</span><br><span class="line">        no_root_squash: 不降低root用户的权限</span><br><span class="line">    其他选项man 5 exports 查看</span><br></pre></td></tr></table></figure><h4 id="创建目录并重启-nfs-服务"><a href="#创建目录并重启-nfs-服务" class="headerlink" title="创建目录并重启 nfs 服务"></a>创建目录并重启 nfs 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /nfs</span><br><span class="line">service nfs-kernel-server restart</span><br></pre></td></tr></table></figure><p>到此，nfs 的服务就搭建好了。</p><h4 id="连接挂载-nfs-服务器"><a href="#连接挂载-nfs-服务器" class="headerlink" title="连接挂载 nfs 服务器"></a>连接挂载 nfs 服务器</h4><p>执行 showmount -e + 主机 IP 测试和 nfs 服务器是否能够联通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-common</span><br><span class="line"></span><br><span class="line">showmount -e 192.168.1.93</span><br></pre></td></tr></table></figure><p>如果看到返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Export list for 192.168.1.93:</span><br><span class="line">/nfs *</span><br></pre></td></tr></table></figure><p>说明文件服务器是 ok 的。</p><p>将该目录挂载到本地，每个机器都需要挂载，包括管理节点的机器。为的是保证每台机器都能够从/mnt/nfs/目录获取数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/nfs</span><br><span class="line">mount 192.168.1.93:/nfs  /mnt/nfs</span><br></pre></td></tr></table></figure><p>访问本地的/mnt/nfs 目录，就可访问服务端共享的目录了。</p><h2 id="部署-Fabric"><a href="#部署-Fabric" class="headerlink" title="部署 Fabric"></a>部署 Fabric</h2><h3 id="部署文件准备"><a href="#部署文件准备" class="headerlink" title="部署文件准备"></a>部署文件准备</h3><p>进入 nfs 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt/nfs</span><br></pre></td></tr></table></figure><p>从 github 获取示例脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/qiushaoxi/fabric-in-swarm.git</span><br><span class="line">cd fabric-in-swarm</span><br></pre></td></tr></table></figure><p>每个节点都需要有 fabric 相关的 docker image，我例子使用 fabric 1.0.0 版本。</p><p>如果还没有，需要在每台机器执行下载脚本，拉取 image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash download-dockerimages.sh</span><br></pre></td></tr></table></figure><p>如果觉得下载速度太慢，可以使用阿里云镜像加速，或者在本地部署 docker hub，具体方法可以参考<a href="http://qiushaoxi.com/2017/12/05/Docker-Hub-Configration/" target="_blank" rel="noopener">本地 Docker Hub 配置</a>.</p><h3 id="执行部署命令"><a href="#执行部署命令" class="headerlink" title="执行部署命令"></a>执行部署命令</h3><p>设置相关环境变量，FABRIC_IP 是你 Swarm 管理节点的 ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_IP=192.168.1.93</span><br></pre></td></tr></table></figure><p>执行 docker stack deploy 命令启动 stack，docker-compose-cli.yaml 是 docker-compose v3 配置文件，配置了相关的 service。</p><p>示例的配置参考 fabric 官方 e2e_cli，1 个 orderer，4 个 peer，一个 cli。命令最后的 e2e 是 stack 的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd e2e_cli</span><br><span class="line">docker stack deploy -c docker-compose-cli.yaml e2e</span><br></pre></td></tr></table></figure><p>docker-compose 文件中配置了 cli 容器会自动执行脚本，执行创建通道、加入通道等一系列操作。</p><p>docker service 会根据每台机器的性能和负载，选择启动 container 的机器。</p><p><img src="/img/fabric-in-swarm/cluster.png" alt="运行情况"></p><h3 id="查看执行结果"><a href="#查看执行结果" class="headerlink" title="查看执行结果"></a>查看执行结果</h3><p>执行下面命令，查询执行日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service logs -f e2e_cli</span><br></pre></td></tr></table></figure><p>如果看不到内容，（我在本地可以用这个命令，阿里云看不到，原因不明）。执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps e2e_cli</span><br></pre></td></tr></table></figure><p>可以看到 cli 容器的 id 和运行在哪台机器上。</p><p>到运行 cli 容器的机器上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [cli_container_id]</span><br></pre></td></tr></table></figure><p>查看执行日志。</p><p>如果最后出现 END-E2E，则说明执行成功。</p><h3 id="移除-stack"><a href="#移除-stack" class="headerlink" title="移除 stack"></a>移除 stack</h3><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm e2e</span><br></pre></td></tr></table></figure><p>就可以停止并移除所有配置启动的 service。</p><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>查看 stack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls</span><br></pre></td></tr></table></figure><p>查看 service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure><p>因为运行 chaincode 的 container 是通过 unix://var/run/docker.sock 启动的，不是由 swarm 启动的，所以通过 docker service 是看不到的。需要到具体执行的机器上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>才能看到。</p><p>而且，就算是停止了 stack 也不会自动删除这些 container，不过因为 peer 停止了，这些 chaincode 的 container 也会自动停止。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.jianshu.com/p/748416621013" target="_blank" rel="noopener">Docker Compose 配置文件详解（V3）</a></p><p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">官方接口文档</a></p><p><a href="http://blog.csdn.net/u014743697/article/details/53004638" target="_blank" rel="noopener">多主机网络下 Docker Swarm 模式的容器管理</a></p><p><a href="https://www.cnblogs.com/MoreExcellent/p/7222895.html" target="_blank" rel="noopener">ubuntu 16.04 nfs 服务的搭建</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;fabric 部署本来就是一件麻烦的事情，如果还涉及到多机环境部署那就更加的麻烦了。&lt;br&gt;因为 fabric 推荐部署在 docker 环境中，那很自然地想到通过集群部署工具来部署 fabric。本文就通过例子来说明如何在 Swarm 集群中部署 fabric 区块链网络。&lt;/p&gt;
&lt;p&gt;还有之前看到过张海宁的&lt;a href=&quot;https://github.com/hainingzhang/articles/blob/master/fabric_multi_nodes/FabricMultiNodev2-3.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;k8s 部署方案&lt;/a&gt;，供大家参考。&lt;/p&gt;
&lt;p&gt;文中所有 IP 地址,如 192.168.1.93，都需要根据你本地的情况输入。&lt;/p&gt;
&lt;p&gt;本例子 github 地址：&lt;a href=&quot;https://github.com/qiushaoxi/fabric-in-swarm.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fabric-in-swarm&lt;/a&gt; , 欢迎 star.&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链技术" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="Hyperledger" scheme="http://yoursite.com/tags/Hyperledger/"/>
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="fabric" scheme="http://yoursite.com/tags/fabric/"/>
    
      <category term="swarm" scheme="http://yoursite.com/tags/swarm/"/>
    
  </entry>
  
</feed>
